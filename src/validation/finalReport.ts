import { readFile, readdir, stat, writeFile } from "node:fs/promises";
import { basename, join } from "node:path";
// NOTE: Node built-in modules are imported with the explicit `node:` prefix to guarantee ESM resolution in Node.js.

import {
  PREFLIGHT_JSONL_FILES,
  writeJsonFile,
  type HttpCheckRequestSnapshot,
} from "./runSetup.js";
import { INTROSPECTION_JSONL_FILES } from "./introspection.js";
import { LOG_STIMULUS_JSONL_FILES } from "./logStimulus.js";
import { TRANSACTIONS_JSONL_FILES } from "./transactions.js";
import { GRAPH_FORGE_JSONL_FILES } from "./graphForge.js";
import { CHILDREN_JSONL_FILES } from "./children.js";
import { PLAN_JSONL_FILES } from "./plans.js";
import { COORDINATION_JSONL_FILES } from "./coordination.js";
import { KNOWLEDGE_JSONL_FILES } from "./knowledge.js";
import { ROBUSTNESS_JSONL_FILES } from "./robustness.js";
import { PERFORMANCE_JSONL_FILES } from "./performance.js";
import { SECURITY_JSONL_FILES } from "./security.js";

/** Relative filename of the final aggregated findings artefact. */
export const FINAL_REPORT_FINDINGS_FILENAME = "findings.json";
/** Relative filename of the Markdown status summary persisted in `report/`. */
export const FINAL_REPORT_SUMMARY_FILENAME = "summary.md";
/** Relative filename of the remediation plan persisted in `report/`. */
export const FINAL_REPORT_RECOMMENDATIONS_FILENAME = "recommendations.md";

/** Location of the introspection summary produced by stage 1 automation. */
const INTROSPECTION_SUMMARY_RELATIVE_PATH = join("report", "introspection_summary.json");
/** Location of the validation context captured during the preflight checks. */
const CONTEXT_RELATIVE_PATH = join("report", "context.json");
/** Location of the generic HTTP log summary persisted by the log capture helper. */
const LOG_SUMMARY_RELATIVE_PATH = join("logs", "summary.json");
/** Filename of the planning, coordination, knowledge, robustness, performance and security summaries. */
const CHILDREN_SUMMARY_RELATIVE_PATH = join("report", "children_summary.json");
const PLANS_SUMMARY_RELATIVE_PATH = join("report", "plans_summary.json");
const COORDINATION_SUMMARY_RELATIVE_PATH = join("report", "coordination_summary.json");
const KNOWLEDGE_SUMMARY_RELATIVE_PATH = join("report", "knowledge_summary.json");
const ROBUSTNESS_SUMMARY_RELATIVE_PATH = join("report", "robustness_summary.json");
const PERFORMANCE_SUMMARY_RELATIVE_PATH = join("report", "perf_summary.json");
const SECURITY_SUMMARY_RELATIVE_PATH = join("report", "security_summary.json");

/**
 * Describes the artefact buckets (JSONL inputs/outputs/events, HTTP logs,
 * summaries and auxiliary folders) produced by a given validation stage. The
 * definition keeps paths relative to the run root so the helper can compose
 * absolute locations lazily when required.
 */
interface StageDefinition {
  readonly id: string;
  readonly label: string;
  readonly inputs?: string | null;
  readonly outputs?: string | null;
  readonly events?: string | null;
  readonly log?: string | null;
  readonly summary?: string | null;
  readonly artefacts?: readonly string[] | null;
}

/** Immutable catalogue describing the run artefacts generated by each stage. */
const STAGE_DEFINITIONS: readonly StageDefinition[] = [
  {
    id: "00",
    label: "Préflight & environnement",
    inputs: PREFLIGHT_JSONL_FILES.inputs,
    outputs: PREFLIGHT_JSONL_FILES.outputs,
    summary: CONTEXT_RELATIVE_PATH,
  },
  {
    id: "01",
    label: "Introspection du serveur MCP",
    inputs: INTROSPECTION_JSONL_FILES.inputs,
    outputs: INTROSPECTION_JSONL_FILES.outputs,
    events: INTROSPECTION_JSONL_FILES.events,
    log: INTROSPECTION_JSONL_FILES.log,
    summary: INTROSPECTION_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "02",
    label: "Journalisation & santé",
    inputs: LOG_STIMULUS_JSONL_FILES.inputs,
    outputs: LOG_STIMULUS_JSONL_FILES.outputs,
    log: LOG_STIMULUS_JSONL_FILES.log,
    summary: LOG_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "03",
    label: "Transactions & graphes",
    inputs: TRANSACTIONS_JSONL_FILES.inputs,
    outputs: TRANSACTIONS_JSONL_FILES.outputs,
    events: TRANSACTIONS_JSONL_FILES.events,
    log: TRANSACTIONS_JSONL_FILES.log,
    artefacts: ["artifacts/graphs"],
  },
  {
    id: "04",
    label: "Graph forge / analyse",
    inputs: GRAPH_FORGE_JSONL_FILES.inputs,
    outputs: GRAPH_FORGE_JSONL_FILES.outputs,
    events: GRAPH_FORGE_JSONL_FILES.events,
    log: GRAPH_FORGE_JSONL_FILES.log,
    artefacts: ["artifacts/forge"],
  },
  {
    id: "05",
    label: "Enfants / self-fork",
    inputs: CHILDREN_JSONL_FILES.inputs,
    outputs: CHILDREN_JSONL_FILES.outputs,
    events: CHILDREN_JSONL_FILES.events,
    log: CHILDREN_JSONL_FILES.log,
    summary: CHILDREN_SUMMARY_RELATIVE_PATH,
    artefacts: ["artifacts/children"],
  },
  {
    id: "06",
    label: "Planification & exécution",
    inputs: PLAN_JSONL_FILES.inputs,
    outputs: PLAN_JSONL_FILES.outputs,
    events: PLAN_JSONL_FILES.events,
    log: PLAN_JSONL_FILES.log,
    summary: PLANS_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "07",
    label: "Coordination multi-agent",
    inputs: COORDINATION_JSONL_FILES.inputs,
    outputs: COORDINATION_JSONL_FILES.outputs,
    events: COORDINATION_JSONL_FILES.events,
    log: COORDINATION_JSONL_FILES.log,
    summary: COORDINATION_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "08",
    label: "Connaissance & valeurs",
    inputs: KNOWLEDGE_JSONL_FILES.inputs,
    outputs: KNOWLEDGE_JSONL_FILES.outputs,
    events: KNOWLEDGE_JSONL_FILES.events,
    log: KNOWLEDGE_JSONL_FILES.log,
    summary: KNOWLEDGE_SUMMARY_RELATIVE_PATH,
    artefacts: ["artifacts/knowledge"],
  },
  {
    id: "09",
    label: "Robustesse & erreurs",
    inputs: ROBUSTNESS_JSONL_FILES.inputs,
    outputs: ROBUSTNESS_JSONL_FILES.outputs,
    events: ROBUSTNESS_JSONL_FILES.events,
    log: ROBUSTNESS_JSONL_FILES.log,
    summary: ROBUSTNESS_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "10",
    label: "Performance",
    inputs: PERFORMANCE_JSONL_FILES.inputs,
    outputs: PERFORMANCE_JSONL_FILES.outputs,
    events: PERFORMANCE_JSONL_FILES.events,
    log: PERFORMANCE_JSONL_FILES.log,
    summary: PERFORMANCE_SUMMARY_RELATIVE_PATH,
  },
  {
    id: "11",
    label: "Sécurité & redaction",
    inputs: SECURITY_JSONL_FILES.inputs,
    outputs: SECURITY_JSONL_FILES.outputs,
    events: SECURITY_JSONL_FILES.events,
    log: SECURITY_JSONL_FILES.log,
    summary: SECURITY_SUMMARY_RELATIVE_PATH,
  },
];

/**
 * Declares the minimum coverage expectations for a given validation stage.
 * These constraints are used to detect missing scenarios or JSON-RPC methods
 * so the final report can surface incomplete playbook executions directly in
 * the findings and Markdown summary.
 */
interface StageCoverageRule {
  readonly stageId: string;
  readonly expectedScenarios?: readonly string[] | null;
  readonly expectedMethods?: readonly string[] | null;
  readonly expectedCalls?: readonly string[] | null;
}

/**
 * Stage coverage rules derived from the validation checklist. The initial
 * entries focus on Stage 03 (transactions), Stage 04 (graph forge), Stage 05
 * (children), Stage 06 (planification), Stage 07 (coordination) and Stage 08
 * (knowledge & valeurs) documents the required scenarios and JSON-RPC calls for
 * these phases.
 * Stage 09 (robustesse & erreurs) is also tracked so the final report can flag
 * missing defensive probes such as invalid schema, idempotency and crash
 * simulations when operators forget to execute them. Stage 10 (performance)
 * keeps latency and concurrency expectations in sync with the checklist so
 * throughput probes are surfaced when omitted during a run.
 * Additional stages can be appended here over time without modifying the
 * aggregation loop.
 */
const STAGE_COVERAGE_RULES: readonly StageCoverageRule[] = [
  {
    stageId: "03",
    expectedScenarios: ["nominal", "error", "concurrency", "export"],
    expectedMethods: [
      "tx_begin",
      "graph_diff",
      "graph_patch",
      "tx_commit",
      "tx_rollback",
      "graph_lock",
      "graph_unlock",
      "values_graph_export",
      "causal_export",
    ],
  },
  {
    stageId: "04",
    expectedScenarios: ["graph_forge_analyze", "graph_state_autosave"],
    expectedMethods: ["tools/call"],
    expectedCalls: [
      "graph_forge_analyze",
      "graph_state_autosave:start",
      "graph_state_autosave:stop",
    ],
  },
  {
    stageId: "05",
    expectedScenarios: ["spawn", "attach", "limits", "interaction", "teardown"],
    expectedMethods: [
      "child_spawn_codex",
      "child_attach",
      "child_set_limits",
      "child_send",
      "child_kill",
    ],
  },
  {
    stageId: "06",
    expectedScenarios: ["compile", "run_bt", "reactive", "lifecycle", "cancellation"],
    expectedMethods: [
      "plan_compile_bt",
      "plan_run_bt",
      "plan_run_reactive",
      "plan_status",
      "plan_pause",
      "plan_resume",
      "plan_cancel",
      "op_cancel",
    ],
  },
  {
    stageId: "07",
    expectedScenarios: ["blackboard", "contract-net", "consensus", "stigmergy"],
    expectedMethods: [
      "bb_get",
      "bb_query",
      "bb_set",
      "bb_watch",
      "bb_watch_poll",
      "cnp_announce",
      "cnp_award",
      "cnp_poll",
      "consensus_status",
      "consensus_vote",
      "stig_decay",
      "stig_mark",
      "stig_snapshot",
    ],
  },
  {
    stageId: "08",
    expectedScenarios: ["knowledge", "values"],
    expectedMethods: [
      "causal_export",
      "kg_assist",
      "kg_get_subgraph",
      "kg_suggest_plan",
      "values_explain",
      "values_graph_export",
    ],
  },
  {
    stageId: "09",
    expectedScenarios: ["child-crash", "idempotency", "invalid-schema", "timeout", "unknown-tool"],
    expectedMethods: [
      "child_spawn_codex",
      "graph_diff",
      "plan_run_reactive",
      "tool_unknown_method",
      "tx_begin",
    ],
  },
  {
    stageId: "10",
    expectedScenarios: ["concurrency", "latency"],
    expectedMethods: ["tools/call"],
  },
  {
    stageId: "11",
    expectedScenarios: ["auth", "filesystem", "redaction"],
    expectedMethods: ["mcp_info", "tools/call"],
  },
];

/**
 * Structure describing one JSON-RPC call captured in the run artefacts.  The
 * helper normalises both the request and the response so aggregation logic can
 * operate without having to re-open the raw JSONL files repeatedly.
 */
interface CallTrace {
  readonly stageId: string;
  readonly stageLabel: string;
  readonly name: string | null;
  readonly method: string | null;
  readonly toolName: string | null;
  readonly scenario: string | null;
  readonly status: number | null;
  readonly errorMessage: string | null;
  readonly durationMs: number | null;
  readonly startedAt: string | null;
}

/** Aggregated counters maintained per tool while scanning JSONL artefacts. */
interface MutableToolAggregate {
  readonly toolName: string;
  method: string | null;
  readonly stages: Set<string>;
  readonly scenarios: Set<string>;
  readonly durations: number[];
  totalCalls: number;
  successCount: number;
  errorCount: number;
}

/** Public representation of a tool aggregate surfaced in the findings report. */
export interface ToolAggregateSummary {
  readonly toolName: string;
  readonly method: string | null;
  readonly stages: readonly string[];
  readonly scenarios: readonly string[];
  readonly totalCalls: number;
  readonly successCount: number;
  readonly errorCount: number;
  readonly status: "OK" | "KO" | "partiel";
  readonly latency: {
    readonly averageMs: number | null;
    readonly p50Ms: number | null;
    readonly p95Ms: number | null;
    readonly p99Ms: number | null;
    readonly maxMs: number | null;
  };
}

/** Snapshot describing the completion status of a checklist stage. */
export interface StageReportSummary {
  readonly id: string;
  readonly label: string;
  readonly completed: boolean;
  readonly totalCalls: number;
  readonly errorCount: number;
  readonly eventsCaptured: number;
  readonly eventSequenceMonotonic: boolean | null;
  /** Total bytes across inputs/outputs/events logs, summaries and artefact folders. */
  readonly artefactBytes: number;
  /** Scenarios captured during the stage, sorted alphabetically for readability. */
  readonly scenarios: readonly string[];
  /** Scenarios expected by the checklist but missing from artefacts. */
  readonly missingScenarios: readonly string[];
  /** Call labels captured for the stage, sorted alphabetically for display. */
  readonly calls: readonly string[];
  /** Call labels expected by the checklist but missing from artefacts. */
  readonly missingCalls: readonly string[];
  /** JSON-RPC methods exercised by the stage. */
  readonly methods: readonly string[];
  /** Methods expected by the checklist but absent from artefacts. */
  readonly missingMethods: readonly string[];
  readonly notes: string;
}

/** Description of a failed JSON-RPC call surfaced to operators. */
export interface IncidentSummary {
  readonly stageId: string;
  readonly stageLabel: string;
  readonly callName: string | null;
  readonly method: string | null;
  readonly status: number | null;
  readonly errorMessage: string | null;
  readonly startedAt: string | null;
}

/** Metrics summarising the entire validation run. */
export interface FinalReportMetrics {
  readonly totalCalls: number;
  readonly errorCount: number;
  readonly uniqueMethods: number;
  readonly uniqueTools: number;
  readonly uniqueScenarios: number;
  readonly stagesCompleted: number;
}

/** High-level indicators derived from the run artefacts. */
export interface FinalReportKpis {
  readonly totalEvents: number;
  readonly eventsByStage: ReadonlyArray<{ stageId: string; count: number }>;
  readonly eventSequences: ReadonlyArray<{ stageId: string; monotonic: boolean | null }>;
  readonly artefactBytes: {
    readonly total: number;
    /** Size breakdown combining JSONL files, HTTP logs, summaries and stage folders. */
    readonly byStage: ReadonlyArray<{ stageId: string; bytes: number }>;
  };
}

/** Coverage breakdown comparing expected tools to exercised tools. */
export interface ToolCoverageSummary {
  readonly expectedTools: number | null;
  readonly coveredTools: number;
  readonly missingTools: readonly string[];
  readonly unexpectedTools: readonly string[];
}

/** Structure persisted to `report/findings.json`. */
export interface FinalFindingsDocument {
  readonly generatedAt: string;
  readonly runId: string;
  readonly versions: {
    readonly node: string | null;
    readonly npm: string | null;
    readonly app: string | null;
    readonly sdk: string | null;
  };
  readonly metrics: FinalReportMetrics;
  readonly stages: readonly StageReportSummary[];
  readonly tools: readonly ToolAggregateSummary[];
  readonly incidents: readonly IncidentSummary[];
  readonly coverage: ToolCoverageSummary;
  readonly kpis: FinalReportKpis;
}

/** Result returned by {@link runFinalReport}. */
export interface FinalReportResult {
  readonly runId: string;
  readonly generatedAt: string;
  readonly findingsPath: string;
  readonly summaryPath: string;
  readonly recommendationsPath: string;
  readonly findings: FinalFindingsDocument;
  readonly summaryMarkdown: string;
  readonly recommendationsMarkdown: string;
}

/** Optional configuration accepted by {@link runFinalReport}. */
export interface FinalReportOptions {
  /** Optional function returning the current time (used by tests for determinism). */
  readonly now?: () => Date;
  /** Optional list of expected tool names overriding the introspection payload. */
  readonly expectedToolsOverride?: readonly string[];
  /** Optional path to the workspace `package.json` (defaults to the repository root). */
  readonly packageJsonPath?: string;
}

/**
 * Reads a JSONL file and returns an array of parsed objects. Missing files are
 * tolerated: the helper returns an empty array instead of throwing, which keeps
 * the final report resilient even when some stages were not executed.
 */
async function readJsonlFile(filePath: string): Promise<Record<string, unknown>[]> {
  try {
    const raw = await readFile(filePath, "utf8");
    return raw
      .split(/\n+/)
      .map((line) => line.trim())
      .filter((line) => line.length > 0)
      .map((line) => JSON.parse(line) as Record<string, unknown>);
  } catch (error: unknown) {
    if (isMissingFileError(error)) {
      return [];
    }
    throw error;
  }
}

/** Reads a JSON file when it exists; otherwise returns {@code null}. */
async function readJsonFileIfPresent<T>(filePath: string): Promise<T | null> {
  try {
    const raw = await readFile(filePath, "utf8");
    return JSON.parse(raw) as T;
  } catch (error: unknown) {
    if (isMissingFileError(error)) {
      return null;
    }
    throw error;
  }
}

/** Counts the number of entries contained in a JSONL file. */
/**
 * Returns the size of a file or directory in bytes. Directories are traversed
 * recursively so operators get a consolidated number for JSONL artefacts, HTTP
 * logs and stage-specific folders. Missing paths are treated as zero-length so
 * partially executed stages do not break the report generation.
 */
async function resolvePathSize(targetPath: string, depth = 0): Promise<number> {
  if (depth > 16) {
    // Defensive guard preventing cyclic symlinks or abnormally deep structures
    // from exhausting the stack during recursive traversal.
    return 0;
  }

  try {
    const info = await stat(targetPath);
    if (info.isDirectory()) {
      const entries = await readdir(targetPath);
      let total = 0;
      for (const entry of entries) {
        total += await resolvePathSize(join(targetPath, entry), depth + 1);
      }
      return total;
    }
    return info.size;
  } catch (error: unknown) {
    if (isMissingFileError(error)) {
      return 0;
    }
    throw error;
  }
}

/** Detects Node.js errno exceptions representing missing files. */
function isMissingFileError(error: unknown): boolean {
  if (!error || typeof error !== "object") {
    return false;
  }
  return (error as NodeJS.ErrnoException).code === "ENOENT";
}

/**
 * Recursively searches the provided payload for a numeric `seq` attribute so
 * we can assess event ordering even if the attribute is nested under
 * `event.seq` or `payload.seq`. The traversal depth is intentionally capped to
 * avoid accidental infinite loops on cyclical structures.
 */
function findNumericSequenceValue(input: unknown, depth = 0): number | null {
  if (!input || typeof input !== "object" || depth > 4) {
    return null;
  }

  if (Array.isArray(input)) {
    for (const candidate of input) {
      const value = findNumericSequenceValue(candidate, depth + 1);
      if (value !== null) {
        return value;
      }
    }
    return null;
  }

  const record = input as Record<string, unknown>;
  for (const [key, value] of Object.entries(record)) {
    if (key === "seq" && typeof value === "number" && Number.isFinite(value)) {
      return value;
    }
    if (value && typeof value === "object") {
      const nested = findNumericSequenceValue(value, depth + 1);
      if (nested !== null) {
        return nested;
      }
    }
  }
  return null;
}

/**
 * Analyses a list of event entries and reports whether the discovered sequence
 * numbers follow a strictly increasing order. When no numeric `seq` could be
 * extracted the helper returns {@code null} so callers can surface an
 * "indisponible" status instead of incorrectly reporting success or failure.
 */
function analyseEventSequence(entries: readonly Record<string, unknown>[]): boolean | null {
  let previous: number | null = null;
  let observed = false;

  for (const entry of entries) {
    const sequence = findNumericSequenceValue(entry);
    if (sequence === null) {
      continue;
    }
    observed = true;
    if (previous !== null && sequence <= previous) {
      return false;
    }
    previous = sequence;
  }

  return observed ? true : null;
}

/** Extracts the JSON-RPC method from a recorded request snapshot. */
function extractJsonRpcMethod(request: HttpCheckRequestSnapshot | undefined): string | null {
  if (!request || typeof request !== "object") {
    return null;
  }
  const body = (request as HttpCheckRequestSnapshot).body;
  if (!body || typeof body !== "object") {
    return null;
  }
  const method = (body as { method?: unknown }).method;
  return typeof method === "string" && method.length > 0 ? method : null;
}

/**
 * Derives a logical tool identifier from a JSON-RPC request. For `tools/call`
 * invocations the helper returns the `params.name` attribute so operators can
 * quickly identify which MCP tool was exercised.
 */
function extractToolName(method: string | null, request: HttpCheckRequestSnapshot | undefined): string | null {
  if (!method) {
    return null;
  }
  if (method !== "tools/call") {
    return method;
  }
  if (!request || typeof request !== "object") {
    return method;
  }
  const body = request.body;
  if (!body || typeof body !== "object") {
    return method;
  }
  const params = (body as { params?: unknown }).params;
  if (!params || typeof params !== "object") {
    return method;
  }
  const name = (params as { name?: unknown }).name;
  return typeof name === "string" && name.trim().length > 0 ? name : method;
}

/** Reads the `scenario` attribute from a JSONL artefact entry if available. */
function extractScenarioFromArtefact(entry: unknown): string | null {
  if (!entry || typeof entry !== "object") {
    return null;
  }
  const scenario = (entry as { scenario?: unknown }).scenario;
  if (typeof scenario !== "string") {
    return null;
  }
  const trimmed = scenario.trim();
  return trimmed.length > 0 ? trimmed : null;
}

/** Attempts to parse a validation scenario name from the recorded call label. */
/**
 * Normalises recorded call labels so coverage checks remain resilient to
 * whitespace variations. Real validation runs sometimes serialise
 * `graph_state_autosave start` instead of the canonical
 * `graph_state_autosave:start`, which would otherwise make the Stage 04
 * coverage hints report a false negative. The helper only rewrites known
 * aliases so other call names remain untouched for traceability.
 */
function normaliseCallName(name: string | null): string | null {
  if (!name || typeof name !== "string") {
    return null;
  }

  const trimmed = name.trim();
  if (!trimmed) {
    return null;
  }

  if (trimmed.includes(":")) {
    return trimmed;
  }

  const canonical = trimmed.replace(/\s+/g, " ");
  const lowerCanonical = canonical.toLowerCase();

  if (lowerCanonical === "graph_state_autosave start") {
    return "graph_state_autosave:start";
  }

  if (lowerCanonical === "graph_state_autosave stop") {
    return "graph_state_autosave:stop";
  }

  return canonical;
}

function extractScenarioFromName(name: string | null): string | null {
  if (!name) {
    return null;
  }
  const separatorIndex = name.indexOf(":");
  if (separatorIndex === -1) {
    const trimmed = name.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  return name.slice(0, separatorIndex);
}

/** Determines whether an HTTP response should be flagged as erroneous. */
function isErrorResponse(response: Record<string, unknown> | undefined): boolean {
  if (!response || typeof response !== "object") {
    return true;
  }
  const status = response.status;
  if (typeof status === "number" && status >= 400) {
    return true;
  }
  if (status === 0) {
    return true;
  }
  const body = response.body;
  if (!body || typeof body !== "object") {
    return false;
  }
  if ((body as { error?: unknown }).error !== undefined) {
    return true;
  }
  return false;
}

/**
 * Generates a readable error message from a JSON-RPC response body so the
 * incident list can provide actionable hints to operators.
 */
function describeErrorBody(body: unknown): string | null {
  if (!body || typeof body !== "object") {
    return null;
  }
  if ((body as { error?: unknown }).error) {
    const errorValue = (body as { error: unknown }).error;
    if (typeof errorValue === "string") {
      return errorValue;
    }
    return JSON.stringify(errorValue);
  }
  if ((body as { result?: unknown }).result) {
    const result = (body as { result: unknown }).result;
    if (result && typeof result === "object" && (result as { error?: unknown }).error) {
      const errorField = (result as { error: unknown }).error;
      if (typeof errorField === "string") {
        return errorField;
      }
      return JSON.stringify(errorField);
    }
  }
  return null;
}

/** Computes the arithmetic mean of the provided samples. */
function computeAverage(samples: readonly number[]): number | null {
  if (!samples.length) {
    return null;
  }
  const sum = samples.reduce((accumulator, value) => accumulator + value, 0);
  return sum / samples.length;
}

/** Returns the percentile value for the provided samples. */
function computePercentile(samples: readonly number[], percentile: number): number | null {
  if (!samples.length) {
    return null;
  }
  const sorted = [...samples].sort((a, b) => a - b);
  const index = Math.min(sorted.length - 1, Math.max(0, Math.floor(percentile * (sorted.length - 1))));
  return sorted[index];
}

/** Converts a mutable tool aggregate into its public summary representation. */
function toToolAggregateSummary(entry: MutableToolAggregate): ToolAggregateSummary {
  const status = entry.errorCount === 0 ? "OK" : entry.successCount === 0 ? "KO" : "partiel";
  const average = computeAverage(entry.durations);
  const p50 = computePercentile(entry.durations, 0.5);
  const p95 = computePercentile(entry.durations, 0.95);
  const p99 = computePercentile(entry.durations, 0.99);
  const max = entry.durations.length ? Math.max(...entry.durations) : null;

  return {
    toolName: entry.toolName,
    method: entry.method,
    stages: Array.from(entry.stages).sort(),
    scenarios: Array.from(entry.scenarios).sort(),
    totalCalls: entry.totalCalls,
    successCount: entry.successCount,
    errorCount: entry.errorCount,
    status,
    latency: {
      averageMs: average !== null ? Number(average.toFixed(2)) : null,
      p50Ms: p50 !== null ? Number(p50.toFixed(2)) : null,
      p95Ms: p95 !== null ? Number(p95.toFixed(2)) : null,
      p99Ms: p99 !== null ? Number(p99.toFixed(2)) : null,
      maxMs: max !== null ? Number(max.toFixed(2)) : null,
    },
  };
}

/** Extracts the npm version from the process user agent when available. */
function inferNpmVersion(): string | null {
  const userAgent = process.env.npm_config_user_agent;
  if (!userAgent) {
    return null;
  }
  const npmMatch = /npm\/(?<version>[0-9]+\.[0-9]+\.[0-9]+)/.exec(userAgent);
  return npmMatch?.groups?.version ?? null;
}

/** Reads the application and SDK versions from `package.json`. */
async function readPackageVersions(packageJsonPath: string): Promise<{ app: string | null; sdk: string | null }> {
  try {
    const raw = await readFile(packageJsonPath, "utf8");
    const manifest = JSON.parse(raw) as {
      version?: unknown;
      dependencies?: Record<string, unknown>;
    };
    const appVersion = typeof manifest.version === "string" ? manifest.version : null;
    const sdkVersionCandidate = manifest.dependencies?.["@modelcontextprotocol/sdk"];
    const sdkVersion = typeof sdkVersionCandidate === "string" ? sdkVersionCandidate : null;
    return { app: appVersion, sdk: sdkVersion };
  } catch (error: unknown) {
    if (isMissingFileError(error)) {
      return { app: null, sdk: null };
    }
    throw error;
  }
}

/** Extracts tool names advertised in the introspection summary document. */
function extractExpectedToolsFromIntrospection(summary: unknown): string[] {
  if (!summary || typeof summary !== "object") {
    return [];
  }
  const toolsPayload = (summary as { tools?: unknown }).tools;
  if (!toolsPayload || typeof toolsPayload !== "object") {
    return [];
  }
  const tools = (toolsPayload as { tools?: unknown }).tools;
  if (!Array.isArray(tools)) {
    return [];
  }
  const names = new Set<string>();
  for (const tool of tools) {
    if (typeof tool === "string" && tool.trim().length > 0) {
      names.add(tool.trim());
      continue;
    }
    if (tool && typeof tool === "object") {
      const name = (tool as { name?: unknown }).name;
      if (typeof name === "string" && name.trim().length > 0) {
        names.add(name.trim());
      }
    }
  }
  return Array.from(names).sort();
}

/**
 * Appends stage-specific diagnostics extracted from structured summaries so the
 * generic checklist notes can expose extra context (for example whether the
 * Stage 05 child spawn succeeded and which identifier was returned).
 */
function appendStageSpecificDetails(
  stageId: string,
  summaryDocument: unknown,
  note: string,
): string {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return note;
  }
  if (stageId === "02") {
    const logDetails = describeLogSummaryDiagnostics(summaryDocument);
    if (logDetails) {
      return `${note}; ${logDetails}`;
    }
  }
  if (stageId === "05") {
    let enrichedNote = note;
    const spawnOutcome = describeChildrenSpawnOutcome(summaryDocument);
    if (spawnOutcome) {
      enrichedNote = `${enrichedNote}; ${spawnOutcome}`;
    }
    const limitDiagnostics = describeChildrenLimitDiagnostics(summaryDocument);
    if (limitDiagnostics) {
      enrichedNote = `${enrichedNote}; ${limitDiagnostics}`;
    }
    return enrichedNote;
  }
  if (stageId === "10") {
    const performanceDetails = describePerformanceDiagnostics(summaryDocument);
    if (performanceDetails) {
      return `${note}; ${performanceDetails}`;
    }
  }
  if (stageId === "11") {
    const securityDetails = describeSecurityDiagnostics(summaryDocument);
    if (securityDetails) {
      return `${note}; ${securityDetails}`;
    }
  }
  return note;
}

/** Formats HTTP log message excerpts so the final report remains concise. */
function formatLogExcerptForSummary(value: string): string {
  const normalised = value.replace(/\s+/g, " ").trim();
  if (normalised.length <= 80) {
    return normalised;
  }
  return `${normalised.slice(0, 79)}…`;
}

/**
 * Extracts diagnostics from the Stage 02 HTTP log summary so the aggregated
 * report highlights the observed volume, error counters and most frequent
 * message.  The helper intentionally tolerates partially populated summaries so
 * operators still receive partial insight when some metrics were unavailable.
 */
function describeLogSummaryDiagnostics(summaryDocument: unknown): string | null {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return null;
  }

  const record = summaryDocument as {
    totalLines?: unknown;
    errorLines?: unknown;
    warnLines?: unknown;
    infoLines?: unknown;
    parseFailures?: unknown;
    topMessages?: unknown;
  };

  const totalLines = typeof record.totalLines === "number" && Number.isFinite(record.totalLines)
    ? record.totalLines
    : null;
  const errorLines = typeof record.errorLines === "number" && Number.isFinite(record.errorLines)
    ? record.errorLines
    : null;
  const warnLines = typeof record.warnLines === "number" && Number.isFinite(record.warnLines)
    ? record.warnLines
    : null;
  const infoLines = typeof record.infoLines === "number" && Number.isFinite(record.infoLines)
    ? record.infoLines
    : null;
  const parseFailures = typeof record.parseFailures === "number" && Number.isFinite(record.parseFailures)
    ? record.parseFailures
    : null;

  const segments: string[] = [];

  if (totalLines !== null) {
    const counters: string[] = [];
    if (errorLines !== null) {
      counters.push(`erreurs ${errorLines}`);
    }
    if (warnLines !== null) {
      counters.push(`avertissements ${warnLines}`);
    }
    if (counters.length === 0 && infoLines !== null) {
      counters.push(`infos ${infoLines}`);
    }
    if (parseFailures !== null && parseFailures > 0) {
      counters.push(`échecs parse ${parseFailures}`);
    }
    const suffix = counters.length ? ` (${counters.join(", ")})` : "";
    segments.push(`journal HTTP ${totalLines} ligne(s)${suffix}`);
  } else {
    const counters: string[] = [];
    if (errorLines !== null) {
      counters.push(`erreurs ${errorLines}`);
    }
    if (warnLines !== null) {
      counters.push(`avertissements ${warnLines}`);
    }
    if (parseFailures !== null && parseFailures > 0) {
      counters.push(`échecs parse ${parseFailures}`);
    }
    if (counters.length) {
      segments.push(counters.join(", "));
    }
  }

  const topMessages = Array.isArray(record.topMessages) ? record.topMessages : [];
  for (const entry of topMessages) {
    if (!entry || typeof entry !== "object") {
      continue;
    }
    const candidate = entry as { text?: unknown; count?: unknown };
    const text = typeof candidate.text === "string" && candidate.text.trim().length > 0
      ? formatLogExcerptForSummary(candidate.text)
      : null;
    const count = typeof candidate.count === "number" && Number.isFinite(candidate.count)
      ? candidate.count
      : null;
    if (text && count !== null) {
      segments.push(`top "${text}" ×${count}`);
      break;
    }
  }

  if (!segments.length) {
    return null;
  }

  return segments.join("; ");
}

/**
 * Extracts a concise description of the Stage 05 child spawn attempt from the
 * persisted summary so operators can immediately see the outcome inside the
 * aggregated report.
 */
function describeChildrenSpawnOutcome(summaryDocument: unknown): string | null {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return null;
  }

  const record = summaryDocument as {
    childId?: unknown;
    calls?: unknown;
  };

  const calls = Array.isArray(record.calls) ? record.calls : [];
  let spawnStatus: number | null = null;
  for (const entry of calls) {
    if (!entry || typeof entry !== "object") {
      continue;
    }
    const call = entry as { method?: unknown; scenario?: unknown; status?: unknown };
    const method = call.method;
    const scenario = call.scenario;
    if (method === "child_spawn_codex" || scenario === "spawn") {
      const statusValue = call.status;
      if (typeof statusValue === "number" && Number.isFinite(statusValue)) {
        spawnStatus = statusValue;
      } else if (typeof statusValue === "string" && statusValue.trim().length > 0) {
        const parsed = Number.parseInt(statusValue, 10);
        spawnStatus = Number.isFinite(parsed) ? parsed : null;
      }
      break;
    }
  }

  if (spawnStatus === null) {
    return null;
  }

  const childIdRaw = record.childId;
  const childId = typeof childIdRaw === "string" && childIdRaw.trim().length > 0 ? childIdRaw.trim() : null;
  const success = spawnStatus >= 200 && spawnStatus < 400;
  const details: string[] = [`statut ${spawnStatus}`];
  if (childId) {
    details.push(`id ${childId}`);
  }
  const descriptor = details.join(", ");
  return success ? `spawn enfant réussi (${descriptor})` : `spawn enfant en échec (${descriptor})`;
}

/**
 * Summarises the Stage 05 resource limit evidence so the final report highlights
 * that the tightened quotas triggered at least one monitoring event. The
 * helper extracts the limit event count alongside the most frequent limit
 * types, tolerating partially populated summaries for resilience.
 */
function describeChildrenLimitDiagnostics(summaryDocument: unknown): string | null {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return null;
  }

  const record = summaryDocument as { events?: unknown };
  if (!record.events || typeof record.events !== "object") {
    return null;
  }

  const eventsPayload = record.events as {
    total?: unknown;
    limitEvents?: unknown;
    types?: unknown;
  };

  const segments: string[] = [];

  // Extract the limit event counters, accepting both numeric and string values
  // so serialisation changes do not break the aggregation.
  const limitEventsValue = eventsPayload.limitEvents;
  let limitEvents: number | null = null;
  if (typeof limitEventsValue === "number" && Number.isFinite(limitEventsValue)) {
    limitEvents = limitEventsValue;
  } else if (typeof limitEventsValue === "string" && limitEventsValue.trim().length > 0) {
    const parsed = Number.parseInt(limitEventsValue, 10);
    limitEvents = Number.isFinite(parsed) ? parsed : null;
  }

  const totalValue = eventsPayload.total;
  let totalEvents: number | null = null;
  if (typeof totalValue === "number" && Number.isFinite(totalValue)) {
    totalEvents = totalValue;
  } else if (typeof totalValue === "string" && totalValue.trim().length > 0) {
    const parsed = Number.parseInt(totalValue, 10);
    totalEvents = Number.isFinite(parsed) ? parsed : null;
  }

  if (limitEvents !== null) {
    const coverageSuffix = totalEvents !== null ? `/${totalEvents}` : "";
    segments.push(`évènements limite ${limitEvents}${coverageSuffix}`);
  }

  const typesPayload = eventsPayload.types;
  if (typesPayload && typeof typesPayload === "object") {
    const entries: Array<{ type: string; count: number }> = [];
    for (const [typeName, value] of Object.entries(typesPayload as Record<string, unknown>)) {
      if (typeof typeName !== "string" || typeName.trim().length === 0) {
        continue;
      }
      if (typeof value !== "number" || !Number.isFinite(value)) {
        continue;
      }
      entries.push({ type: typeName.trim(), count: value });
    }
    if (entries.length > 0) {
      const limitSpecific = entries.filter((entry) => entry.type.toLowerCase().includes("limit"));
      const breakdownSource = limitSpecific.length > 0 ? limitSpecific : entries;
      breakdownSource.sort((a, b) => {
        if (b.count === a.count) {
          return a.type.localeCompare(b.type);
        }
        return b.count - a.count;
      });
      const formatted = breakdownSource
        .slice(0, 3)
        .map((entry) => `${entry.type} ×${entry.count}`)
        .join(", ");
      if (formatted.length > 0) {
        segments.push(`types ${formatted}`);
      }
    }
  }

  if (segments.length === 0) {
    return null;
  }

  return segments.join("; ");
}

/**
 * Extracts human readable diagnostics for Stage 10 so the final report can
 * highlight the latency sample size, percentile distribution, concurrency
 * outcomes and HTTP log growth captured during the performance phase.
 */
function describePerformanceDiagnostics(summaryDocument: unknown): string | null {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return null;
  }

  const record = summaryDocument as {
    latency?: unknown;
    concurrency?: unknown;
    logs?: unknown;
  };

  const segments: string[] = [];

  const latency = record.latency as
    | {
        label?: unknown;
        toolName?: unknown;
        samples?: unknown;
        p95Ms?: unknown;
        p99Ms?: unknown;
        maxMs?: unknown;
      }
    | undefined;
  if (latency && typeof latency === "object") {
    const labelCandidate =
      typeof latency.label === "string" && latency.label.trim().length > 0
        ? latency.label.trim()
        : typeof latency.toolName === "string" && latency.toolName.trim().length > 0
        ? latency.toolName.trim()
        : null;
    const samples = typeof latency.samples === "number" ? latency.samples : null;
    const p95 = typeof latency.p95Ms === "number" ? latency.p95Ms : null;
    const p99 = typeof latency.p99Ms === "number" ? latency.p99Ms : null;
    const max = typeof latency.maxMs === "number" ? latency.maxMs : null;
    const metrics: string[] = [];
    if (p95 !== null) {
      metrics.push(`p95 ${formatMillis(p95)} ms`);
    }
    if (p99 !== null) {
      metrics.push(`p99 ${formatMillis(p99)} ms`);
    }
    if (p99 === null && p95 === null && max !== null) {
      metrics.push(`max ${formatMillis(max)} ms`);
    }
    const label = labelCandidate ?? "latence";
    const samplesText = samples !== null ? `${samples} échantillon(s)` : "échantillons inconnus";
    const metricsSuffix = metrics.length ? ` (${metrics.join(", ")})` : "";
    segments.push(`latence ${label} — ${samplesText}${metricsSuffix}`);
  }

  const concurrency = record.concurrency as { groups?: unknown } | undefined;
  if (concurrency && typeof concurrency === "object") {
    const groups = Array.isArray(concurrency.groups) ? concurrency.groups : [];
    const groupSummaries = groups
      .map((group) => {
        if (!group || typeof group !== "object") {
          return null;
        }
        const entry = group as { group?: unknown; totalCalls?: unknown; success?: unknown; failure?: unknown };
        const name = typeof entry.group === "string" && entry.group.trim().length > 0 ? entry.group.trim() : null;
        const total = typeof entry.totalCalls === "number" ? entry.totalCalls : null;
        const success = typeof entry.success === "number" ? entry.success : null;
        const failure = typeof entry.failure === "number" ? entry.failure : null;
        if (!name || total === null || success === null || failure === null) {
          return null;
        }
        return `concurrence ${name}: ${success}/${total} succès (${failure} échec(s))`;
      })
      .filter((value): value is string => value !== null);
    if (groupSummaries.length) {
      segments.push(groupSummaries.join(", "));
    }
  }

  const logs = record.logs as
    | {
        growthBytes?: unknown;
        rotated?: unknown;
      }
    | undefined;
  if (logs && typeof logs === "object") {
    const growth = typeof logs.growthBytes === "number" ? logs.growthBytes : null;
    if (growth !== null) {
      segments.push(`journal HTTP ${growth >= 0 ? "+" : ""}${growth} octet(s)`);
    }
    const rotated = typeof logs.rotated === "boolean" ? logs.rotated : false;
    if (rotated) {
      segments.push("rotation du journal détectée");
    }
  }

  if (!segments.length) {
    return null;
  }
  return segments.join("; ");
}

/**
 * Extracts Stage 11 diagnostics such as unauthorized status codes, redaction
 * leak counters and filesystem rejection outcomes so operators see the
 * security evidence directly in the aggregated summary.
 */
function describeSecurityDiagnostics(summaryDocument: unknown): string | null {
  if (!summaryDocument || typeof summaryDocument !== "object") {
    return null;
  }

  const record = summaryDocument as {
    unauthorized?: unknown;
    redaction?: unknown;
    pathValidation?: unknown;
  };

  const segments: string[] = [];

  const unauthorized = record.unauthorized as { calls?: unknown } | undefined;
  if (unauthorized && typeof unauthorized === "object") {
    const calls = Array.isArray(unauthorized.calls) ? unauthorized.calls : [];
    if (calls.length) {
      let successCount = 0;
      const statuses = new Set<number>();
      for (const call of calls) {
        if (!call || typeof call !== "object") {
          continue;
        }
        const entry = call as { status?: unknown; success?: unknown };
        const status = typeof entry.status === "number" ? entry.status : null;
        if (status !== null) {
          statuses.add(status);
        }
        if (entry.success === true) {
          successCount += 1;
        }
      }
      const statusList = statuses.size ? Array.from(statuses).sort((a, b) => a - b).join(", ") : "inconnu";
      segments.push(`auth sans jeton: ${successCount}/${calls.length} rejet(s) (status ${statusList})`);
    }
  }

  const redaction = record.redaction as { calls?: unknown } | undefined;
  if (redaction && typeof redaction === "object") {
    const calls = Array.isArray(redaction.calls) ? redaction.calls : [];
    if (calls.length) {
      let responseLeaks = 0;
      let eventLeaks = 0;
      let cleanCount = 0;
      for (const call of calls) {
        if (!call || typeof call !== "object") {
          continue;
        }
        const entry = call as { leakedInResponse?: unknown; leakedInEvents?: unknown };
        const responseLeak = entry.leakedInResponse === true;
        const eventLeak = entry.leakedInEvents === true;
        if (responseLeak) {
          responseLeaks += 1;
        }
        if (eventLeak) {
          eventLeaks += 1;
        }
        if (!responseLeak && !eventLeak) {
          cleanCount += 1;
        }
      }
      segments.push(
        `redaction: ${cleanCount}/${calls.length} masque(s) valide(s) (fuites réponses ${responseLeaks}, événements ${eventLeaks})`,
      );
    }
  }

  const pathValidation = record.pathValidation as { calls?: unknown } | undefined;
  if (pathValidation && typeof pathValidation === "object") {
    const calls = Array.isArray(pathValidation.calls) ? pathValidation.calls : [];
    if (calls.length) {
      let blocked = 0;
      for (const call of calls) {
        if (!call || typeof call !== "object") {
          continue;
        }
        const entry = call as { status?: unknown };
        const status = typeof entry.status === "number" ? entry.status : null;
        if (status !== null && status >= 400) {
          blocked += 1;
        }
      }
      segments.push(`filesystem interdit: ${blocked}/${calls.length} rejet(s)`);
    }
  }

  if (!segments.length) {
    return null;
  }
  return segments.join("; ");
}

/** Formats millisecond metrics with two decimals while stripping trailing zeros. */
function formatMillis(value: number): string {
  const fixed = value.toFixed(2);
  if (fixed.includes(".")) {
    return fixed.replace(/\.0+$/, "").replace(/(\.[0-9]*[1-9])0+$/, "$1");
  }
  return fixed;
}

/** Builds a concise note describing the completion status of a stage. */
function buildStageNotes(
  totalCalls: number,
  errorCount: number,
  summaryPresent: boolean,
  eventsCaptured: number,
  eventSequenceMonotonic: boolean | null,
  missingScenarios: readonly string[],
  missingMethods: readonly string[],
  missingCalls: readonly string[],
): string {
  if (totalCalls === 0 && !summaryPresent) {
    return appendCoverageSuffix(
      `Aucun appel capturé${describeEventSequenceNote(eventsCaptured, eventSequenceMonotonic)}`,
      missingScenarios,
      missingMethods,
      missingCalls,
    );
  }
  if (totalCalls === 0 && summaryPresent) {
    return appendCoverageSuffix(
      `Résumé disponible (exécution externe)${describeEventSequenceNote(eventsCaptured, eventSequenceMonotonic)}`,
      missingScenarios,
      missingMethods,
      missingCalls,
    );
  }
  if (errorCount === 0) {
    return appendCoverageSuffix(
      `${totalCalls} appel(s) sans erreur${describeEventSequenceNote(eventsCaptured, eventSequenceMonotonic)}`,
      missingScenarios,
      missingMethods,
      missingCalls,
    );
  }
  return appendCoverageSuffix(
    `${errorCount}/${totalCalls} appel(s) en erreur${describeEventSequenceNote(eventsCaptured, eventSequenceMonotonic)}`,
    missingScenarios,
    missingMethods,
    missingCalls,
  );
}

/** Builds a suffix describing the detected event sequence ordering. */
function describeEventSequenceNote(eventsCaptured: number, eventSequenceMonotonic: boolean | null): string {
  if (eventsCaptured === 0) {
    return "";
  }
  if (eventSequenceMonotonic === true) {
    return "; séquence événements OK";
  }
  if (eventSequenceMonotonic === false) {
    return "; séquence événements non monotone";
  }
  return "; séquence événements indisponible";
}

/**
 * Appends coverage diagnostics highlighting the scenarios/methods that were
 * expected but not observed during a stage. Returning a single helper keeps the
 * wording consistent across all note variations.
 */
function appendCoverageSuffix(
  note: string,
  missingScenarios: readonly string[],
  missingMethods: readonly string[],
  missingCalls: readonly string[],
): string {
  const coverageHints: string[] = [];
  if (missingScenarios.length) {
    coverageHints.push(`scénarios manquants: ${missingScenarios.join(", ")}`);
  }
  if (missingMethods.length) {
    coverageHints.push(`méthodes manquantes: ${missingMethods.join(", ")}`);
  }
  if (missingCalls.length) {
    coverageHints.push(`appels manquants: ${missingCalls.join(", ")}`);
  }
  if (!coverageHints.length) {
    return note;
  }
  return `${note}; ${coverageHints.join("; ")}`;
}

/** Formats a number for display inside Markdown tables. */
function formatCell(value: number | null): string {
  return typeof value === "number" && Number.isFinite(value) ? value.toString(10) : "—";
}

/** Builds the Markdown summary persisted alongside the findings document. */
function buildSummaryMarkdown(params: {
  readonly runId: string;
  readonly generatedAt: string;
  readonly metrics: FinalReportMetrics;
  readonly stages: readonly StageReportSummary[];
  readonly tools: readonly ToolAggregateSummary[];
  readonly coverage: ToolCoverageSummary;
  readonly kpis: FinalReportKpis;
}): string {
  const stageRows = params.stages
    .map((stage) =>
      [
        stage.label,
        stage.completed ? "✅" : "⚠️",
        formatCell(stage.totalCalls),
        formatCell(stage.errorCount),
        stage.notes,
      ].join(" | "),
    )
    .join("\n");

  const toolRows = params.tools
    .map((tool) =>
      [
        tool.toolName,
        tool.status,
        formatCell(tool.totalCalls),
        formatCell(tool.errorCount),
        formatCell(tool.latency.p50Ms),
        formatCell(tool.latency.p95Ms),
        formatCell(tool.latency.p99Ms),
        tool.stages.join(", "),
      ].join(" | "),
    )
    .join("\n");

  const missingTools = params.coverage.missingTools.length
    ? params.coverage.missingTools.join(", ")
    : "aucun";
  const unexpectedTools = params.coverage.unexpectedTools.length
    ? params.coverage.unexpectedTools.join(", ")
    : "aucun";

  const eventsLines = params.kpis.eventsByStage
    .map((entry) => `- Stage ${entry.stageId} : ${entry.count} événement(s)`)
    .join("\n");

  const sequenceLines = params.kpis.eventSequences
    .map((entry) => {
      const status = entry.monotonic === true ? "séquence OK" : entry.monotonic === false ? "séquence non monotone" : "séquence indisponible";
      return `  - Stage ${entry.stageId} : ${status}`;
    })
    .join("\n");

  const artefactLines = params.kpis.artefactBytes.byStage
    .map((entry) => `  - Stage ${entry.stageId} : ${entry.bytes} octet(s) d'artefacts`)
    .join("\n");

  return [
    `# Validation report — ${params.runId}`,
    "",
    `*Généré le ${params.generatedAt}*`,
    "",
    "## Résumé exécutif",
    "",
    `- ${params.metrics.totalCalls} appel(s) JSON-RPC (erreurs : ${params.metrics.errorCount})`,
    `- ${params.metrics.stagesCompleted}/${params.stages.length} étapes couvertes`,
    `- ${params.metrics.uniqueTools} outil(s) MCP exercés (${params.metrics.uniqueMethods} méthodes JSON-RPC)` ,
    "",
    "## Progression par étape",
    "",
    "| Étape | Statut | Appels | Erreurs | Notes |",
    "| --- | --- | --- | --- | --- |",
    stageRows,
    "",
    "## Synthèse par outil",
    "",
    "| Outil | Statut | Appels | Erreurs | p50 (ms) | p95 (ms) | p99 (ms) | Étapes |",
    "| --- | --- | --- | --- | --- | --- | --- | --- |",
    toolRows || "| Aucun | — | — | — | — | — | — | — |",
    "",
    "## Couverture attendue",
    "",
    `- Outils attendus : ${params.coverage.expectedTools ?? "inconnu"}`,
    `- Outils couverts : ${params.coverage.coveredTools}`,
    `- Manquants : ${missingTools}`,
    `- Supplémentaires : ${unexpectedTools}`,
    "",
    "## Indicateurs complémentaires",
    "",
    `- Total d'événements : ${params.kpis.totalEvents}`,
    eventsLines || "- Aucun flux d'événements capturé",
    sequenceLines ? ["- Séquences événements :", sequenceLines].join("\n") : "- Séquences événements : aucune donnée exploitable",
    `- Taille totale des artefacts : ${params.kpis.artefactBytes.total} octet(s)`,
    artefactLines ? ["- Répartition par étape des artefacts :", artefactLines].join("\n") : "- Répartition par étape indisponible",
  ].join("\n");
}

/** Builds the Markdown remediation plan surfaced to operators. */
function buildRecommendationsMarkdown(params: {
  readonly runId: string;
  readonly incidents: readonly IncidentSummary[];
  readonly coverage: ToolCoverageSummary;
  readonly metrics: FinalReportMetrics;
}): string {
  const p0Lines: string[] = [];
  for (const incident of params.incidents) {
    const description = `- ${incident.stageId} / ${incident.method ?? "méthode inconnue"} (${incident.status ?? "?"}) → ${
      incident.errorMessage ?? "erreur non renseignée"
    }`;
    p0Lines.push(description);
  }

  const p1Lines: string[] = [];
  if (params.coverage.missingTools.length) {
    p1Lines.push(`- Couvrir les outils manquants : ${params.coverage.missingTools.join(", ")}`);
  }
  if (params.metrics.stagesCompleted < STAGE_DEFINITIONS.length) {
    p1Lines.push(
      `- Exécuter les étapes restantes (${params.metrics.stagesCompleted}/${STAGE_DEFINITIONS.length} terminées) afin de valider le playbook complet`,
    );
  }

  const p2Lines = [
    "- Corréler les latences agrégées avec les journaux HTTP pour identifier d'éventuels goulets d'étranglement",
  ];

  return [
    `# Recommandations — ${params.runId}`,
    "",
    "## P0 — Correctifs immédiats",
    "",
    p0Lines.length ? p0Lines.join("\n") : "- Aucun incident bloquant relevé",
    "",
    "## P1 — Améliorations priorisées",
    "",
    p1Lines.length ? p1Lines.join("\n") : "- Couverture exhaustive déjà assurée",
    "",
    "## P2 — Optimisations",
    "",
    p2Lines.join("\n"),
  ].join("\n");
}

/**
 * Aggregates every JSONL artefact produced during the validation run to build
 * a consolidated findings document plus operator-friendly Markdown summaries.
 */
export async function runFinalReport(runRoot: string, options: FinalReportOptions = {}): Promise<FinalReportResult> {
  if (!runRoot) {
    throw new Error("runFinalReport requires a validation run root directory");
  }

  const resolvedRunRoot = join(runRoot);
  const runId = basename(resolvedRunRoot);
  const now = options.now?.() ?? new Date();
  const generatedAt = now.toISOString();

  const toolAggregates = new Map<string, MutableToolAggregate>();
  const incidents: IncidentSummary[] = [];
  const stages: StageReportSummary[] = [];

  const uniqueMethods = new Set<string>();
  const uniqueTools = new Set<string>();
  const uniqueScenarios = new Set<string>();

  let totalCalls = 0;
  let totalErrors = 0;
  let totalEvents = 0;
  let totalArtefactBytes = 0;

  const eventsByStage: Array<{ stageId: string; count: number }> = [];
  const artefactSizes: Array<{ stageId: string; bytes: number }> = [];
  const eventSequences: Array<{ stageId: string; monotonic: boolean | null }> = [];

  for (const stage of STAGE_DEFINITIONS) {
    const stageInputsPath = stage.inputs ? join(resolvedRunRoot, stage.inputs) : null;
    const stageOutputsPath = stage.outputs ? join(resolvedRunRoot, stage.outputs) : null;
    const stageEventsPath = stage.events ? join(resolvedRunRoot, stage.events) : null;
    const stageSummaryPath = stage.summary ? join(resolvedRunRoot, stage.summary) : null;
    const stageLogPath = stage.log ? join(resolvedRunRoot, stage.log) : null;
    const stageArtefactPaths = stage.artefacts?.map((relative) => join(resolvedRunRoot, relative)) ?? [];
    const summaryDocument = stageSummaryPath ? await readJsonFileIfPresent(stageSummaryPath) : null;

    const inputs = stageInputsPath ? await readJsonlFile(stageInputsPath) : [];
    const outputs = stageOutputsPath ? await readJsonlFile(stageOutputsPath) : [];
    const pairCount = Math.min(inputs.length, outputs.length);

    const stageEventEntries = stageEventsPath ? await readJsonlFile(stageEventsPath) : [];
    const stageEvents = stageEventEntries.length;
    if (stageEvents > 0) {
      eventsByStage.push({ stageId: stage.id, count: stageEvents });
      totalEvents += stageEvents;
    }

    const eventSequenceMonotonic = stageEvents > 0 ? analyseEventSequence(stageEventEntries) : null;
    if (stageEvents > 0) {
      eventSequences.push({ stageId: stage.id, monotonic: eventSequenceMonotonic });
    }

    const artefactTargets: string[] = [];
    if (stageInputsPath) {
      artefactTargets.push(stageInputsPath);
    }
    if (stageOutputsPath) {
      artefactTargets.push(stageOutputsPath);
    }
    if (stageEventsPath) {
      artefactTargets.push(stageEventsPath);
    }
    if (stageLogPath) {
      artefactTargets.push(stageLogPath);
    }
    if (stageSummaryPath) {
      artefactTargets.push(stageSummaryPath);
    }
    artefactTargets.push(...stageArtefactPaths);

    let artefactBytes = 0;
    for (const target of artefactTargets) {
      artefactBytes += await resolvePathSize(target);
    }
    if (artefactBytes > 0) {
      artefactSizes.push({ stageId: stage.id, bytes: artefactBytes });
      totalArtefactBytes += artefactBytes;
    }

    let stageErrors = 0;
    const stageScenarios = new Set<string>();
    const stageMethods = new Set<string>();
    const stageCalls = new Set<string>();

    for (let index = 0; index < pairCount; index += 1) {
      const input = inputs[index];
      const output = outputs[index];

      const method = extractJsonRpcMethod(input?.request as HttpCheckRequestSnapshot | undefined);
      if (method) {
        uniqueMethods.add(method);
        stageMethods.add(method);
      }

      const toolName = extractToolName(method, input?.request as HttpCheckRequestSnapshot | undefined);
      if (toolName) {
        uniqueTools.add(toolName);
      }

      const rawCallName =
        typeof input?.name === "string"
          ? input.name
          : typeof output?.name === "string"
          ? output.name
          : null;
      const callName = normaliseCallName(rawCallName);
      if (callName) {
        stageCalls.add(callName);
      }
      const scenarioFromArtefact = extractScenarioFromArtefact(input) ?? extractScenarioFromArtefact(output);
      const scenario = scenarioFromArtefact ?? extractScenarioFromName(callName);
      if (scenario) {
        uniqueScenarios.add(scenario);
        stageScenarios.add(scenario);
      }

      const response = output?.response as Record<string, unknown> | undefined;
      const status = typeof response?.status === "number" ? (response.status as number) : null;
      const duration = typeof output?.durationMs === "number" ? (output.durationMs as number) : null;
      const isError = isErrorResponse(response);
      const errorMessage = describeErrorBody(response?.body);

      const trace: CallTrace = {
        stageId: stage.id,
        stageLabel: stage.label,
        name: callName,
        method,
        toolName,
        scenario,
        status,
        errorMessage,
        durationMs: duration,
        startedAt: typeof output?.startedAt === "string" ? output.startedAt : null,
      };

      totalCalls += 1;
      if (isError) {
        totalErrors += 1;
        stageErrors += 1;
        incidents.push({
          stageId: trace.stageId,
          stageLabel: trace.stageLabel,
          callName: trace.name,
          method: trace.method,
          status: trace.status,
          errorMessage: trace.errorMessage,
          startedAt: trace.startedAt,
        });
      }

      if (toolName) {
        const key = toolName;
        let aggregate = toolAggregates.get(key);
        if (!aggregate) {
          aggregate = {
            toolName,
            method,
            stages: new Set(),
            scenarios: new Set(),
            durations: [],
            totalCalls: 0,
            successCount: 0,
            errorCount: 0,
          };
          toolAggregates.set(key, aggregate);
        }
        aggregate.method = aggregate.method ?? method ?? null;
        aggregate.totalCalls += 1;
        aggregate.stages.add(stage.id);
        if (scenario) {
          aggregate.scenarios.add(scenario);
        }
        if (duration !== null && Number.isFinite(duration)) {
          aggregate.durations.push(duration);
        }
        if (isError) {
          aggregate.errorCount += 1;
        } else {
          aggregate.successCount += 1;
        }
      }
    }

    const summaryPresent = summaryDocument !== null;
    const observedScenarios = Array.from(stageScenarios).sort();
    const observedMethods = Array.from(stageMethods).sort();
    const observedCalls = Array.from(stageCalls).sort();
    const coverageRule = STAGE_COVERAGE_RULES.find((rule) => rule.stageId === stage.id);
    const expectedScenarios = coverageRule?.expectedScenarios?.slice().sort() ?? [];
    const expectedMethods = coverageRule?.expectedMethods?.slice().sort() ?? [];
    const expectedCalls = coverageRule?.expectedCalls?.slice().sort() ?? [];
    const missingScenarios = expectedScenarios.filter((scenario) => !stageScenarios.has(scenario));
    const missingMethods = expectedMethods.filter((method) => !stageMethods.has(method));
    const missingCalls = expectedCalls.filter((call) => !stageCalls.has(call));
    const stageCompleted = pairCount > 0 || summaryPresent;
    let notes = buildStageNotes(
      pairCount,
      stageErrors,
      summaryPresent,
      stageEvents,
      eventSequenceMonotonic,
      missingScenarios,
      missingMethods,
      missingCalls,
    );
    notes = appendStageSpecificDetails(stage.id, summaryDocument, notes);

    stages.push({
      id: stage.id,
      label: stage.label,
      completed: stageCompleted,
      totalCalls: pairCount,
      errorCount: stageErrors,
      eventsCaptured: stageEvents,
      eventSequenceMonotonic,
      artefactBytes,
      scenarios: observedScenarios,
      missingScenarios,
      calls: observedCalls,
      missingCalls,
      methods: observedMethods,
      missingMethods,
      notes,
    });
  }

  const toolSummaries = Array.from(toolAggregates.values())
    .map((entry) => toToolAggregateSummary(entry))
    .sort((a, b) => a.toolName.localeCompare(b.toolName));

  const introspectionSummaryPath = join(resolvedRunRoot, INTROSPECTION_SUMMARY_RELATIVE_PATH);
  const introspectionSummary = await readJsonFileIfPresent<unknown>(introspectionSummaryPath);
  const expectedToolsFromSummary = extractExpectedToolsFromIntrospection(introspectionSummary);
  const expectedTools = options.expectedToolsOverride
    ? Array.from(new Set(options.expectedToolsOverride)).sort()
    : expectedToolsFromSummary;

  const actualToolNames = new Set(toolSummaries.map((tool) => tool.toolName));
  const missingTools = expectedTools.filter((tool) => !actualToolNames.has(tool));
  const unexpectedTools = Array.from(actualToolNames).filter((tool) => !expectedTools.includes(tool)).sort();

  const coverage: ToolCoverageSummary = {
    expectedTools: expectedTools.length ? expectedTools.length : expectedToolsFromSummary.length ? expectedToolsFromSummary.length : null,
    coveredTools: actualToolNames.size,
    missingTools,
    unexpectedTools,
  };

  const metrics: FinalReportMetrics = {
    totalCalls,
    errorCount: totalErrors,
    uniqueMethods: uniqueMethods.size,
    uniqueTools: uniqueTools.size,
    uniqueScenarios: uniqueScenarios.size,
    stagesCompleted: stages.filter((stage) => stage.completed).length,
  };

  const kpis: FinalReportKpis = {
    totalEvents,
    eventsByStage,
    eventSequences,
    artefactBytes: {
      total: totalArtefactBytes,
      byStage: artefactSizes,
    },
  };

  const packageJsonPath = options.packageJsonPath ?? join(process.cwd(), "package.json");
  const packageVersions = await readPackageVersions(packageJsonPath);

  const findings: FinalFindingsDocument = {
    generatedAt,
    runId,
    versions: {
      node: process.version ?? null,
      npm: inferNpmVersion(),
      app: packageVersions.app,
      sdk: packageVersions.sdk,
    },
    metrics,
    stages,
    tools: toolSummaries,
    incidents,
    coverage,
    kpis,
  };

  const summaryMarkdown = buildSummaryMarkdown({
    runId,
    generatedAt,
    metrics,
    stages,
    tools: toolSummaries,
    coverage,
    kpis,
  });

  const recommendationsMarkdown = buildRecommendationsMarkdown({
    runId,
    incidents,
    coverage,
    metrics,
  });

  const findingsPath = join(resolvedRunRoot, "report", FINAL_REPORT_FINDINGS_FILENAME);
  const summaryPath = join(resolvedRunRoot, "report", FINAL_REPORT_SUMMARY_FILENAME);
  const recommendationsPath = join(resolvedRunRoot, "report", FINAL_REPORT_RECOMMENDATIONS_FILENAME);

  await writeJsonFile(findingsPath, findings);
  await writeFile(summaryPath, `${summaryMarkdown}\n`, "utf8");
  await writeFile(recommendationsPath, `${recommendationsMarkdown}\n`, "utf8");

  return {
    runId,
    generatedAt,
    findingsPath,
    summaryPath,
    recommendationsPath,
    findings,
    summaryMarkdown,
    recommendationsMarkdown,
  };
}

