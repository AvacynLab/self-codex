import { writeFile } from "node:fs/promises";
import { join } from "node:path";
// NOTE: Node built-in modules are imported with the explicit `node:` prefix to guarantee ESM resolution in Node.js.

import {
  performHttpCheck,
  toJsonlLine,
  writeJsonFile,
  type HttpCheckSnapshot,
  type HttpEnvironmentSummary,
} from "./runSetup.js";

import type { GraphDescriptorPayload } from "../tools/graphTools.js";

/**
 * Relative artefact targets dedicated to the transaction & graph validation
 * phase (section 3 of the playbook).
 */
export const TRANSACTIONS_JSONL_FILES = {
  inputs: "inputs/02_tx.jsonl",
  outputs: "outputs/02_tx.jsonl",
  events: "events/02_tx.jsonl",
  log: "logs/transactions_http.json",
} as const;

/**
 * Human-readable identifier describing the default graph exercised by the
 * transaction phase.
 */
const DEFAULT_GRAPH_ID = "G_VALIDATION_SAMPLE";

/**
 * Immutable baseline graph descriptor reused across the default call plan.
 */
const DEFAULT_BASE_GRAPH: GraphDescriptorPayload = {
  name: "Validation baseline workflow",
  graph_id: DEFAULT_GRAPH_ID,
  graph_version: 1,
  metadata: {
    stage: "transactions",
    variant: "baseline",
  },
  nodes: [
    { id: "ingest", label: "Ingest", attributes: { lane: "ingestion" } },
    { id: "analyse", label: "Analyse", attributes: { lane: "analysis" } },
  ],
  edges: [{ from: "ingest", to: "analyse", label: "flow", attributes: { channel: "primary" } }],
};

/** Default lock holder used by the nominal transaction workflow. */
const DEFAULT_LOCK_HOLDER = "validation-harness";

/** Alternate holder used to simulate conflicting mutations while a lock is held. */
const CONFLICTING_LOCK_HOLDER = "validation-harness-b";

/** Subdirectory receiving graph-related artefacts generated by the runner. */
const GRAPH_ARTIFACTS_DIR = "artifacts/graphs";

/** Filename persisted when the `causal_export` tool succeeds. */
const CAUSAL_EXPORT_ARTIFACT = "causal_export.json";

/** Filename persisted when the `values_graph_export` tool succeeds. */
const VALUES_GRAPH_ARTIFACT = "values_graph_export.json";

/** Snapshot describing the context forwarded to dynamic parameter factories. */
export interface TransactionCallContext {
  /** HTTP environment used to contact the MCP server. */
  readonly environment: HttpEnvironmentSummary;
  /** Outcomes recorded so far (chronological order). */
  readonly previousCalls: readonly TransactionCallOutcome[];
}

/** Factory signature used when a call requires dynamic JSON-RPC params. */
export type TransactionParamsFactory = (context: TransactionCallContext) => unknown;

/**
 * Specification of a JSON-RPC call executed during the transactions phase.
 */
export interface TransactionCallSpec {
  /** Logical group (nominal, error, concurrency…) advertised in artefacts. */
  readonly scenario: string;
  /** Friendly identifier for traceability (e.g. `tx_begin_initial`). */
  readonly name: string;
  /** JSON-RPC method to invoke (`tx_begin`, `graph_diff`, …). */
  readonly method: string;
  /** Optional params forwarded as-is to the MCP server. */
  readonly params?: unknown | TransactionParamsFactory;
  /** Additional HTTP headers injected on top of the default ones. */
  readonly headers?: Record<string, string>;
  /** Optional idempotency key propagated via the HTTP header. */
  readonly idempotencyKey?: string;
  /** When set to `false`, response events are not recorded in `events/`. */
  readonly captureEvents?: boolean;
  /** Optional callback invoked after the call completes to persist artefacts. */
  readonly afterExecute?: TransactionCallAfterHook;
}

/** Representation of a call after execution (params resolved to JSON values). */
export type ExecutedTransactionCall = Omit<TransactionCallSpec, "params"> & {
  /** Concrete params object that was submitted to the MCP server. */
  readonly params?: unknown;
};

/** Outcome collected for every JSON-RPC call executed during the phase. */
export interface TransactionCallOutcome {
  /** Resolved call descriptor (including the concrete params object). */
  readonly call: ExecutedTransactionCall;
  /** Detailed HTTP artefacts captured by {@link performHttpCheck}. */
  readonly check: HttpCheckSnapshot;
  /** Extracted events (when any) persisted under `events/02_tx.jsonl`. */
  readonly events: unknown[];
}

/** Context propagated to post-call hooks to generate auxiliary artefacts. */
export interface TransactionCallAfterHookContext {
  /** Absolute run directory where artefacts should be persisted. */
  readonly runRoot: string;
  /** HTTP environment used for the validation phase. */
  readonly environment: HttpEnvironmentSummary;
  /** Outcome describing the call that just completed. */
  readonly outcome: TransactionCallOutcome;
  /** Previously recorded outcomes (without the one passed in `outcome`). */
  readonly previousCalls: readonly TransactionCallOutcome[];
}

/** Signature accepted by {@link TransactionCallSpec.afterExecute}. */
export type TransactionCallAfterHook = (
  context: TransactionCallAfterHookContext,
) => Promise<void> | void;

/**
 * Builds a deterministic JSON-RPC identifier for transaction calls.
 */
function buildJsonRpcId(index: number, call: TransactionCallSpec): string {
  const scenarioToken = call.scenario.replace(/[^a-zA-Z0-9]+/g, "-");
  const nameToken = call.name.replace(/[^a-zA-Z0-9]+/g, "-");
  return `transactions_${index}_${scenarioToken}_${nameToken}`;
}

/**
 * Converts a JSON-RPC response body into a `result` object when available.
 */
function extractJsonRpcResult(body: unknown): Record<string, unknown> | null {
  if (!body || typeof body !== "object" || Array.isArray(body)) {
    return null;
  }

  const result = (body as { result?: unknown }).result;
  if (!result || typeof result !== "object" || Array.isArray(result)) {
    return null;
  }

  return result as Record<string, unknown>;
}

/** Convenience helper returning a deep copy of a graph descriptor. */
function cloneGraphDescriptor(graph: GraphDescriptorPayload): GraphDescriptorPayload {
  return JSON.parse(JSON.stringify(graph)) as GraphDescriptorPayload;
}

/**
 * Extracts a graph descriptor from a JSON-RPC result payload. When the result
 * does not expose a `graph` field, the helper returns `null`.
 */
function extractGraph(result: Record<string, unknown> | null): GraphDescriptorPayload | null {
  if (!result) {
    return null;
  }
  const graph = (result as { graph?: unknown }).graph;
  if (!graph || typeof graph !== "object") {
    return null;
  }
  return graph as GraphDescriptorPayload;
}

/**
 * Extracts event arrays emitted by MCP tool responses. The helper tolerates
 * missing or malformed payloads to keep the runner resilient.
 */
function extractEvents(body: unknown): unknown[] {
  const result = extractJsonRpcResult(body);
  if (!result) {
    return [];
  }
  const events = (result as { events?: unknown }).events;
  return Array.isArray(events) ? events : [];
}

/**
 * Persists the JSON-RPC request/response and a structured log entry.
 */
async function appendTransactionCallArtefacts(
  runRoot: string,
  call: ExecutedTransactionCall,
  check: HttpCheckSnapshot,
): Promise<void> {
  const inputEntry = toJsonlLine({
    scenario: call.scenario,
    name: call.name,
    method: call.method,
    startedAt: check.startedAt,
    params: call.params ?? null,
    request: check.request,
  });
  const outputEntry = toJsonlLine({
    scenario: call.scenario,
    name: call.name,
    durationMs: check.durationMs,
    response: check.response,
  });
  const logEntry = `${JSON.stringify(
    {
      scenario: call.scenario,
      name: call.name,
      method: call.method,
      params: call.params ?? null,
      check,
    },
    null,
    2,
  )}\n`;

  await Promise.all([
    writeFile(join(runRoot, TRANSACTIONS_JSONL_FILES.inputs), inputEntry, { encoding: "utf8", flag: "a" }),
    writeFile(join(runRoot, TRANSACTIONS_JSONL_FILES.outputs), outputEntry, { encoding: "utf8", flag: "a" }),
    writeFile(join(runRoot, TRANSACTIONS_JSONL_FILES.log), logEntry, { encoding: "utf8", flag: "a" }),
  ]);
}

/** Appends captured events to the dedicated `.jsonl` artefact. */
async function appendTransactionEvents(
  runRoot: string,
  call: ExecutedTransactionCall,
  events: readonly unknown[],
): Promise<void> {
  if (!events.length) {
    return;
  }

  const capturedAt = new Date().toISOString();
  const payload = events
    .map((event, index) =>
      toJsonlLine({
        scenario: call.scenario,
        source: call.name,
        capturedAt,
        eventIndex: index,
        event,
      }),
    )
    .join("");

  await writeFile(join(runRoot, TRANSACTIONS_JSONL_FILES.events), payload, { encoding: "utf8", flag: "a" });
}

/**
 * Executes the transaction & graph validation calls sequentially and persists
 * artefacts under `runs/validation_…/`.
 */
export async function runTransactionsPhase(
  runRoot: string,
  environment: HttpEnvironmentSummary,
  calls: readonly TransactionCallSpec[] = buildDefaultTransactionCalls(),
): Promise<TransactionCallOutcome[]> {
  if (!runRoot) {
    throw new Error("runTransactionsPhase requires a run root directory");
  }
  if (!environment || !environment.baseUrl) {
    throw new Error("runTransactionsPhase requires a valid HTTP environment");
  }

  const baseHeaders: Record<string, string> = {
    "content-type": "application/json",
    accept: "application/json",
  };
  if (environment.token) {
    baseHeaders.authorization = `Bearer ${environment.token}`;
  }

  const outcomes: TransactionCallOutcome[] = [];

  for (let index = 0; index < calls.length; index += 1) {
    const spec = calls[index];
    const params = typeof spec.params === "function"
      ? (spec.params as TransactionParamsFactory)({ environment, previousCalls: outcomes })
      : spec.params;

    const headers: Record<string, string> = { ...baseHeaders };
    if (spec.headers) {
      for (const [key, value] of Object.entries(spec.headers)) {
        headers[key.toLowerCase()] = value;
      }
    }
    if (spec.idempotencyKey) {
      headers["idempotency-key"] = spec.idempotencyKey;
    }

    const requestBody: Record<string, unknown> = {
      jsonrpc: "2.0",
      id: buildJsonRpcId(index, spec),
      method: spec.method,
    };
    if (params !== undefined) {
      requestBody.params = params;
    }

    const check = await performHttpCheck(`${spec.scenario}:${spec.name}`, {
      method: "POST",
      url: environment.baseUrl,
      headers,
      body: requestBody,
    });

    const executedCall: ExecutedTransactionCall = {
      scenario: spec.scenario,
      name: spec.name,
      method: spec.method,
      // Optional call metadata is only forwarded when provided so enabling
      // `exactOptionalPropertyTypes` does not trigger `undefined` assignments.
      ...(spec.headers ? { headers: spec.headers } : {}),
      ...(spec.idempotencyKey !== undefined ? { idempotencyKey: spec.idempotencyKey } : {}),
      ...(spec.captureEvents !== undefined ? { captureEvents: spec.captureEvents } : {}),
      ...(params !== undefined ? { params } : {}),
    };

    await appendTransactionCallArtefacts(runRoot, executedCall, check);

    const events = spec.captureEvents === false ? [] : extractEvents(check.response.body);
    if (events.length) {
      await appendTransactionEvents(runRoot, executedCall, events);
    }

    const outcome: TransactionCallOutcome = { call: executedCall, check, events };

    if (spec.afterExecute) {
      await spec.afterExecute({
        runRoot,
        environment,
        outcome,
        previousCalls: outcomes,
      });
    }

    outcomes.push(outcome);
  }

  return outcomes;
}

/**
 * Helper returning the most recent outcome matching the provided call name.
 */
function requireOutcome(previous: readonly TransactionCallOutcome[], name: string): TransactionCallOutcome {
  const outcome = [...previous].reverse().find((entry) => entry.call.name === name);
  if (!outcome) {
    throw new Error(`Expected previous call '${name}' to be executed before building dependent params`);
  }
  return outcome;
}

/**
 * Extracts a JSON-RPC result from a prior outcome, throwing when absent.
 */
function requireResult(previous: readonly TransactionCallOutcome[], name: string): Record<string, unknown> {
  const outcome = requireOutcome(previous, name);
  const result = extractJsonRpcResult(outcome.check.response.body);
  if (!result) {
    throw new Error(`Call '${name}' did not return a JSON-RPC result payload`);
  }
  return result;
}

/** Builds the enriched graph descriptor used by the patch plan. */
function buildEnrichedGraph(commitGraph: GraphDescriptorPayload): GraphDescriptorPayload {
  const graph = cloneGraphDescriptor(commitGraph);
  const nodes = Array.isArray(graph.nodes) ? [...graph.nodes] : [];
  const edges = Array.isArray(graph.edges) ? [...graph.edges] : [];

  if (!nodes.some((node) => node.id === "deliver")) {
    nodes.push({ id: "deliver", label: "Deliver", attributes: { lane: "customer" } });
  }
  if (!edges.some((edge) => edge.from === "ship" && edge.to === "deliver")) {
    edges.push({ from: "ship", to: "deliver", label: "handoff", attributes: { channel: "secondary" } });
  }

  return {
    ...graph,
    graph_id: DEFAULT_GRAPH_ID,
    metadata: {
      ...(graph.metadata ?? {}),
      release_channel: "beta",
      release_candidate: true,
    },
    nodes,
    edges,
  } as GraphDescriptorPayload;
}

/** Builds a graph descriptor purposely introducing a cycle for invariant checks. */
function buildCycleGraph(graph: GraphDescriptorPayload): GraphDescriptorPayload {
  const copy = cloneGraphDescriptor(graph);
  const edges = Array.isArray(copy.edges) ? [...copy.edges] : [];
  edges.push({ from: "deliver", to: "ingest", label: "cycle", attributes: { channel: "loop" } });
  return {
    ...copy,
    graph_id: DEFAULT_GRAPH_ID,
    edges,
  } as GraphDescriptorPayload;
}

/**
 * Builds a follow-up graph descriptor that introduces an additional QA node.
 * The helper is used to derive a deterministic patch for the concurrency checks
 * without mutating the previously committed graph payload.
 */
function buildConcurrencyGraph(graph: GraphDescriptorPayload): GraphDescriptorPayload {
  const copy = cloneGraphDescriptor(graph);
  const nodes = Array.isArray(copy.nodes) ? [...copy.nodes] : [];
  if (!nodes.some((node) => node.id === "qa")) {
    nodes.push({ id: "qa", label: "Quality", attributes: { lane: "quality" } });
  }
  const edges = Array.isArray(copy.edges) ? [...copy.edges] : [];
  if (!edges.some((edge) => edge.from === "analyse" && edge.to === "qa")) {
    edges.push({ from: "analyse", to: "qa", label: "handoff", attributes: { channel: "quality" } });
  }
  return {
    ...copy,
    graph_id: DEFAULT_GRAPH_ID,
    nodes,
    edges,
  } as GraphDescriptorPayload;
}

/**
 * Persists the payload returned by the `causal_export` tool so operators can
 * inspect the causal memory snapshot without replaying the JSON-RPC call.
 */
async function persistCausalExportArtefact(runRoot: string, outcome: TransactionCallOutcome): Promise<void> {
  const result = extractJsonRpcResult(outcome.check.response.body);
  if (!result) {
    return;
  }
  const target = join(runRoot, GRAPH_ARTIFACTS_DIR, CAUSAL_EXPORT_ARTIFACT);
  await writeJsonFile(target, result);
}

/**
 * Persists the payload returned by the `values_graph_export` tool so operators
 * can inspect the knowledge values attached to the transactional graph.
 */
async function persistValuesGraphExportArtefact(
  runRoot: string,
  outcome: TransactionCallOutcome,
): Promise<void> {
  const result = extractJsonRpcResult(outcome.check.response.body);
  if (!result) {
    return;
  }
  const target = join(runRoot, GRAPH_ARTIFACTS_DIR, VALUES_GRAPH_ARTIFACT);
  await writeJsonFile(target, result);
}

/**
 * Derives the sequence of JSON-RPC calls required to fulfil section 3 of the
 * validation playbook (transactions, diff/patch, invariant violation).
 */
export function buildDefaultTransactionCalls(): TransactionCallSpec[] {
  return [
    {
      scenario: "nominal",
      name: "tx_begin_initial",
      method: "tx_begin",
      params: {
        graph_id: DEFAULT_GRAPH_ID,
        owner: "validation-harness",
        note: "seed baseline descriptor",
        ttl_ms: 5_000,
        graph: DEFAULT_BASE_GRAPH,
      },
    },
    {
      scenario: "nominal",
      name: "graph_diff_baseline",
      method: "graph_diff",
      params: () => ({
        graph_id: DEFAULT_GRAPH_ID,
        from: { graph: DEFAULT_BASE_GRAPH },
        to: { graph: DEFAULT_BASE_GRAPH },
      }),
    },
    {
      scenario: "nominal",
      name: "tx_apply_enrichment",
      method: "tx_apply",
      params: ({ previousCalls }: TransactionCallContext) => {
        const result = requireResult(previousCalls, "tx_begin_initial");
        const txId = result.tx_id;
        if (typeof txId !== "string" || !txId) {
          throw new Error("tx_apply requires tx_begin to return a tx_id");
        }
        return {
          tx_id: txId,
          operations: [
            { op: "add_node", node: { id: "ship", label: "Ship", attributes: { lane: "delivery" } } },
            { op: "add_edge", edge: { from: "analyse", to: "ship", label: "handoff", attributes: { channel: "secondary" } } },
            { op: "set_node_attribute", id: "analyse", key: "status", value: "in_progress" },
          ],
        };
      },
    },
    {
      scenario: "nominal",
      name: "tx_commit_initial",
      method: "tx_commit",
      params: ({ previousCalls }: TransactionCallContext) => {
        const result = requireResult(previousCalls, "tx_begin_initial");
        const txId = result.tx_id;
        if (typeof txId !== "string" || !txId) {
          throw new Error("tx_commit requires tx_begin to return a tx_id");
        }
        return { tx_id: txId };
      },
    },
    {
      scenario: "nominal",
      name: "graph_diff_post_commit",
      method: "graph_diff",
      params: ({ previousCalls }: TransactionCallContext) => {
        const commitResult = requireResult(previousCalls, "tx_commit_initial");
        const committedGraph = extractGraph(commitResult) ?? DEFAULT_BASE_GRAPH;
        return {
          graph_id: DEFAULT_GRAPH_ID,
          from: { graph: DEFAULT_BASE_GRAPH },
          to: { graph: committedGraph },
        };
      },
    },
    {
      scenario: "nominal",
      name: "graph_diff_patch_plan",
      method: "graph_diff",
      params: ({ previousCalls }: TransactionCallContext) => {
        const commitResult = requireResult(previousCalls, "tx_commit_initial");
        const committedGraph = extractGraph(commitResult);
        if (!committedGraph) {
          throw new Error("graph_diff_patch_plan requires tx_commit to return a graph descriptor");
        }
        const enrichedGraph = buildEnrichedGraph(committedGraph);
        return {
          graph_id: DEFAULT_GRAPH_ID,
          from: { graph: committedGraph },
          to: { graph: enrichedGraph },
        };
      },
    },
    {
      scenario: "nominal",
      name: "graph_lock_owner_primary",
      method: "graph_lock",
      params: {
        graph_id: DEFAULT_GRAPH_ID,
        holder: DEFAULT_LOCK_HOLDER,
        ttl_ms: 15_000,
      },
    },
    {
      scenario: "nominal",
      name: "graph_patch_success",
      method: "graph_patch",
      params: ({ previousCalls }: TransactionCallContext) => {
        const commitResult = requireResult(previousCalls, "tx_commit_initial");
        const diffResult = requireResult(previousCalls, "graph_diff_patch_plan");
        const baseVersion = commitResult.version;
        if (typeof baseVersion !== "number") {
          throw new Error("graph_patch requires tx_commit to expose a numeric version");
        }
        const operations = diffResult.operations;
        if (!Array.isArray(operations) || operations.length === 0) {
          throw new Error("graph_diff_patch_plan did not produce patch operations");
        }
        return {
          graph_id: DEFAULT_GRAPH_ID,
          base_version: baseVersion,
          owner: DEFAULT_LOCK_HOLDER,
          note: "extend workflow",
          patch: operations,
        };
      },
    },
    {
      scenario: "error",
      name: "graph_diff_cycle_plan",
      method: "graph_diff",
      params: ({ previousCalls }: TransactionCallContext) => {
        const patchResult = requireResult(previousCalls, "graph_patch_success");
        const patchedGraph = extractGraph(patchResult);
        if (!patchedGraph) {
          throw new Error("graph_patch_success did not expose the patched graph");
        }
        const cycleGraph = buildCycleGraph(patchedGraph);
        return {
          graph_id: DEFAULT_GRAPH_ID,
          from: { graph: patchedGraph },
          to: { graph: cycleGraph },
        };
      },
    },
    {
      scenario: "error",
      name: "tx_begin_invalid_patch",
      method: "tx_begin",
      params: ({ previousCalls }: TransactionCallContext) => {
        const patchResult = requireResult(previousCalls, "graph_patch_success");
        const patchedGraph = extractGraph(patchResult);
        if (!patchedGraph) {
          throw new Error("graph_patch_success did not expose the patched graph");
        }
        const version = patchResult.committed_version ?? patchResult.version;
        if (typeof version !== "number") {
          throw new Error("graph_patch_success did not expose a committed version");
        }
        return {
          graph_id: DEFAULT_GRAPH_ID,
          owner: DEFAULT_LOCK_HOLDER,
          note: "prepare invalid patch replay inside transaction",
          ttl_ms: 5_000,
          graph: patchedGraph,
          base_version: version,
        };
      },
    },
    {
      scenario: "error",
      name: "tx_apply_invalid_patch",
      method: "tx_apply",
      params: ({ previousCalls }: TransactionCallContext) => {
        const beginResult = requireResult(previousCalls, "tx_begin_invalid_patch");
        const diffResult = requireResult(previousCalls, "graph_diff_cycle_plan");
        const txId = beginResult.tx_id;
        if (typeof txId !== "string" || !txId) {
          throw new Error("tx_apply_invalid_patch requires tx_begin to return a tx_id");
        }
        const operations = diffResult.operations;
        if (!Array.isArray(operations) || operations.length === 0) {
          throw new Error("graph_diff_cycle_plan did not produce operations to replay");
        }
        return {
          tx_id: txId,
          operations,
        };
      },
    },
    {
      scenario: "error",
      name: "tx_rollback_invalid_patch",
      method: "tx_rollback",
      params: ({ previousCalls }: TransactionCallContext) => {
        const beginResult = requireResult(previousCalls, "tx_begin_invalid_patch");
        const txId = beginResult.tx_id;
        if (typeof txId !== "string" || !txId) {
          throw new Error("tx_rollback_invalid_patch requires tx_begin to return a tx_id");
        }
        return {
          tx_id: txId,
          reason: "abort invalid patch replay",
        };
      },
    },
    {
      scenario: "error",
      name: "graph_patch_invariant_violation",
      method: "graph_patch",
      params: ({ previousCalls }: TransactionCallContext) => {
        const patchResult = requireResult(previousCalls, "graph_patch_success");
        const cycleDiff = requireResult(previousCalls, "graph_diff_cycle_plan");
        const version = patchResult.committed_version ?? patchResult.version;
        if (typeof version !== "number") {
          throw new Error("graph_patch_invariant_violation requires a committed version");
        }
        const operations = cycleDiff.operations;
        if (!Array.isArray(operations) || operations.length === 0) {
          throw new Error("graph_diff_cycle_plan did not produce operations to replay");
        }
        return {
          graph_id: DEFAULT_GRAPH_ID,
          base_version: version,
          owner: DEFAULT_LOCK_HOLDER,
          note: "induce cycle for invariant check",
          patch: operations,
          enforce_invariants: true,
        };
      },
    },
    {
      scenario: "concurrency",
      name: "graph_diff_concurrency_plan",
      method: "graph_diff",
      params: ({ previousCalls }: TransactionCallContext) => {
        const patchResult = requireResult(previousCalls, "graph_patch_success");
        const patchedGraph = extractGraph(patchResult);
        if (!patchedGraph) {
          throw new Error("graph_patch_success did not expose the patched graph");
        }
        const targetGraph = buildConcurrencyGraph(patchedGraph);
        return {
          graph_id: DEFAULT_GRAPH_ID,
          from: { graph: patchedGraph },
          to: { graph: targetGraph },
        };
      },
    },
    {
      scenario: "concurrency",
      name: "graph_patch_conflicting_holder",
      method: "graph_patch",
      params: ({ previousCalls }: TransactionCallContext) => {
        const lockResult = requireResult(previousCalls, "graph_lock_owner_primary");
        const diffResult = requireResult(previousCalls, "graph_diff_concurrency_plan");
        const patchedResult = requireResult(previousCalls, "graph_patch_success");
        const version = patchedResult.committed_version ?? patchedResult.version;
        if (typeof version !== "number") {
          throw new Error("graph_patch_conflicting_holder requires a committed version");
        }
        const operations = diffResult.operations;
        if (!Array.isArray(operations) || operations.length === 0) {
          throw new Error("graph_diff_concurrency_plan did not produce patch operations");
        }
        const lockHolder = lockResult.holder;
        if (typeof lockHolder !== "string" || !lockHolder) {
          throw new Error("graph_lock_owner_primary did not expose a holder");
        }
        return {
          graph_id: DEFAULT_GRAPH_ID,
          base_version: version,
          owner: CONFLICTING_LOCK_HOLDER,
          note: `simulate conflicting mutation while lock held by ${lockHolder}`,
          patch: operations,
        };
      },
    },
    {
      scenario: "concurrency",
      name: "graph_unlock_owner_primary",
      method: "graph_unlock",
      params: ({ previousCalls }: TransactionCallContext) => {
        const lockResult = requireResult(previousCalls, "graph_lock_owner_primary");
        const lockId = lockResult.lock_id;
        if (typeof lockId !== "string" || !lockId) {
          throw new Error("graph_unlock requires a lock identifier emitted by graph_lock");
        }
        return { lock_id: lockId };
      },
    },
    {
      scenario: "export",
      name: "values_graph_export_snapshot",
      method: "values_graph_export",
      params: {},
      afterExecute: async ({ runRoot, outcome }) => {
        await persistValuesGraphExportArtefact(runRoot, outcome);
      },
      captureEvents: false,
    },
    {
      scenario: "export",
      name: "causal_export_snapshot",
      method: "causal_export",
      params: {},
      afterExecute: async ({ runRoot, outcome }) => {
        await persistCausalExportArtefact(runRoot, outcome);
      },
      captureEvents: false,
    },
  ];
}

/** Convenience helper exposing the absolute path of the HTTP log file. */
export function resolveTransactionsHttpLogPath(runRoot: string): string {
  return join(runRoot, TRANSACTIONS_JSONL_FILES.log);
}
