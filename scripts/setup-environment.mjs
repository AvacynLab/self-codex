#!/usr/bin/env node
import {
  closeSync,
  existsSync,
  mkdirSync,
  openSync,
  readFileSync,
  unlinkSync,
  writeFileSync,
} from "node:fs";
import { spawn } from "node:child_process";
import { fileURLToPath } from "node:url";
import { dirname, join, resolve } from "node:path";

import {
  buildCommandPlan,
  createCommandRunner,
  ensureBranchAllowed,
  ensureSourceMapNodeOptions,
  assertNodeVersion,
} from "./lib/env-helpers.mjs";

/**
 * Bootstraps a Codex orchestrator deployment without mutating the repository
 * workspace. The script mirrors the "no-write" policy captured in AGENTS.md
 * and is safe to execute on developer machines as well as CI runners. The
 * updated flow now provisions a TOML configuration for both STDIO and HTTP
 * transports and can optionally launch the HTTP server plus FS-Bridge in the
 * background.
 */
const scriptDir = dirname(fileURLToPath(import.meta.url));
const projectRoot = resolve(scriptDir, "..");
const scriptPath = fileURLToPath(import.meta.url);
const isTestEnvironment = process.env.CODEX_SCRIPT_TEST === "1";
const isDryRun = process.env.CODEX_SCRIPT_DRY_RUN === "1";
const invokedDirectly = (() => {
  try {
    return process.argv.length > 1 && resolve(process.argv[1]) === scriptPath;
  } catch {
    return false;
  }
})();

/** Collects side effects so the dry-run mode can expose them to the tests. */
const backgroundActions = [];

function recordBackground(action) {
  backgroundActions.push(action);
}

function coerceBoolean(value) {
  if (!value) {
    return false;
  }
  const normalised = value.trim().toLowerCase();
  return ["1", "true", "yes", "on"].includes(normalised);
}

function escapeTomlString(value) {
  return String(value).replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function coercePort(value) {
  if (!value) {
    return null;
  }
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}

function expandHomePath(rawPath) {
  if (!rawPath || rawPath.trim().length === 0) {
    return rawPath;
  }
  if (!rawPath.startsWith("~")) {
    return rawPath;
  }
  const home = process.env.HOME ?? "";
  const remainder = rawPath.slice(1).replace(/^[/\\]+/, "");
  return home ? join(home, remainder) : remainder;
}

function resolveFsBridgeDirectory(rawValue) {
  const base = expandHomePath(rawValue);
  if (!base || base.trim().length === 0) {
    const home = process.env.HOME ?? "";
    return resolve(home, ".codex", "ipc");
  }
  return resolve(base);
}

function captureEnvironment() {
  const rawHttpEnable = process.env.MCP_HTTP_ENABLE ?? "";
  const env = {
    rawHttpEnable,
    httpEnable: coerceBoolean(rawHttpEnable),
    httpHost: process.env.MCP_HTTP_HOST || "127.0.0.1",
    httpPort: process.env.MCP_HTTP_PORT || "8765",
    httpPath: process.env.MCP_HTTP_PATH || "/mcp",
    httpJson: process.env.MCP_HTTP_JSON || "on",
    httpStateless: process.env.MCP_HTTP_STATELESS || "yes",
    httpToken: process.env.MCP_HTTP_TOKEN || "",
    startMcpBg: process.env.START_MCP_BG === "1",
    fsBridgeDir: resolveFsBridgeDirectory(process.env.MCP_FS_IPC_DIR ?? ""),
  };
  return env;
}

function buildConfigToml(env) {
  const lines = [];
  lines.push(`# Generated by scripts/setup-environment.mjs on ${new Date().toISOString()}`);
  lines.push(`[mcp_servers.self-codex-stdio]`);
  lines.push(`command = "npm"`);
  lines.push(`args = ["run", "start:stdio"]`);
  lines.push(`enabled = false`);
  lines.push(`transport = "stdio"`);
  lines.push(`working_directory = "${escapeTomlString(projectRoot)}"`);
  lines.push("");
  lines.push(`[mcp_servers.self-codex-http]`);
  lines.push(`command = "npm"`);
  lines.push(`args = ["run", "start:http"]`);
  lines.push(`enabled = ${env.httpEnable ? "true" : "false"}`);
  lines.push(`transport = "http"`);
  lines.push(`working_directory = "${escapeTomlString(projectRoot)}"`);
  lines.push(`host = "${escapeTomlString(env.httpHost)}"`);
  const numericPort = coercePort(env.httpPort);
  if (numericPort !== null) {
    lines.push(`port = ${numericPort}`);
  } else {
    lines.push(`port = "${escapeTomlString(env.httpPort)}"`);
  }
  lines.push(`path = "${escapeTomlString(env.httpPath)}"`);
  lines.push(`json = "${escapeTomlString(env.httpJson)}"`);
  lines.push(`stateless = "${escapeTomlString(env.httpStateless)}"`);
  lines.push(`token = "${escapeTomlString(env.httpToken)}"`);
  lines.push("");
  lines.push(`[mcp_servers.self-codex-http.environment]`);
  lines.push(`MCP_HTTP_ENABLE = "${escapeTomlString(env.rawHttpEnable)}"`);
  lines.push(`MCP_HTTP_HOST = "${escapeTomlString(env.httpHost)}"`);
  lines.push(`MCP_HTTP_PORT = "${escapeTomlString(env.httpPort)}"`);
  lines.push(`MCP_HTTP_PATH = "${escapeTomlString(env.httpPath)}"`);
  lines.push(`MCP_HTTP_JSON = "${escapeTomlString(env.httpJson)}"`);
  lines.push(`MCP_HTTP_STATELESS = "${escapeTomlString(env.httpStateless)}"`);
  if (env.httpToken) {
    lines.push(`MCP_HTTP_TOKEN = "${escapeTomlString(env.httpToken)}"`);
  }
  lines.push(`START_MCP_BG = "${env.startMcpBg ? "1" : ""}"`);
  lines.push(`MCP_FS_IPC_DIR = "${escapeTomlString(env.fsBridgeDir)}"`);
  lines.push("");
  return `${lines.join("\n")}`;
}

function killProcessIfPresent(pidPath, label) {
  if (!existsSync(pidPath)) {
    recordBackground({ action: "skip-kill", label, reason: "pid-missing", pidPath });
    return false;
  }
  let pid = 0;
  try {
    pid = Number(readFileSync(pidPath, "utf8").trim());
  } catch (error) {
    recordBackground({
      action: "kill-error",
      label,
      pidPath,
      message: error instanceof Error ? error.message : String(error),
    });
    return false;
  }
  if (!Number.isFinite(pid) || pid <= 0) {
    recordBackground({ action: "kill-error", label, pidPath, message: "invalid pid" });
    if (!isDryRun) {
      try {
        unlinkSync(pidPath);
      } catch {
        /* ignore */
      }
    }
    return false;
  }
  if (isDryRun) {
    recordBackground({ action: "kill", label, pid, pidPath });
    return true;
  }
  try {
    process.kill(pid, "SIGTERM");
    recordBackground({ action: "kill", label, pid, pidPath });
  } catch (error) {
    recordBackground({
      action: "kill-error",
      label,
      pid,
      pidPath,
      message: error instanceof Error ? error.message : String(error),
    });
  }
  try {
    unlinkSync(pidPath);
  } catch {
    /* ignore */
  }
  return true;
}

function spawnDetached(label, scriptName, logFilename, pidFilename) {
  const command = "npm";
  const args = ["run", scriptName];
  const logPath = join(projectRoot, logFilename);
  const pidPath = join(projectRoot, pidFilename);
  const envWithSourceMaps = ensureSourceMapNodeOptions(process.env);
  recordBackground({
    action: "spawn-attempt",
    label,
    command,
    args,
    logPath,
    pidPath,
    dryRun: isDryRun,
    nodeOptions: envWithSourceMaps.NODE_OPTIONS,
  });
  if (isDryRun) {
    return { ok: true, command, args, logPath, pidPath };
  }

  let outFd;
  let errFd;
  try {
    outFd = openSync(logPath, "a");
    errFd = openSync(logPath, "a");
    const child = spawn(command, args, {
      cwd: projectRoot,
      detached: true,
      stdio: ["ignore", outFd, errFd],
      env: envWithSourceMaps,
    });
    writeFileSync(pidPath, `${child.pid}\n`, "utf8");
    child.unref();
    recordBackground({ action: "spawned", label, pid: child.pid, command, args, logPath, pidPath });
    return { ok: true, pid: child.pid, pidPath, logPath };
  } catch (error) {
    recordBackground({
      action: "spawn-error",
      label,
      command,
      args,
      logPath,
      pidPath,
      message: error instanceof Error ? error.message : String(error),
    });
    try {
      unlinkSync(pidPath);
    } catch {
      /* ignore */
    }
    return { ok: false };
  } finally {
    if (outFd !== undefined) {
      try {
        closeSync(outFd);
      } catch {
        /* ignore */
      }
    }
    if (errFd !== undefined) {
      try {
        closeSync(errFd);
      } catch {
        /* ignore */
      }
    }
  }
}

function ensureFsBridgeDirectories(baseDir) {
  const targets = [
    baseDir,
    join(baseDir, "requests"),
    join(baseDir, "responses"),
    join(baseDir, "errors"),
  ];
  for (const directory of targets) {
    recordBackground({ action: "ensure-dir", path: directory, dryRun: isDryRun });
    if (isDryRun) {
      continue;
    }
    mkdirSync(directory, { recursive: true });
  }
}

async function main() {
  backgroundActions.length = 0;
  assertNodeVersion();
  const { runCommand, recordedCommands } = createCommandRunner({
    projectRoot,
    dryRun: isDryRun,
  });

  await ensureBranchAllowed(async () => {
    const result = await runCommand("git", ["rev-parse", "--abbrev-ref", "HEAD"], {
      captureOutput: true,
    });
    return result.stdout;
  });

  const hasLockFile =
    existsSync(join(projectRoot, "package-lock.json")) ||
    existsSync(join(projectRoot, "npm-shrinkwrap.json"));
  const hasGraphForge = existsSync(join(projectRoot, "graph-forge", "tsconfig.json"));

  for (const step of buildCommandPlan(hasLockFile, { includeGraphForge: hasGraphForge })) {
    console.log(`[setup] ${step.description}`);
    await runCommand(step.command, step.args);
  }

  const envSnapshot = captureEnvironment();
  const configDir = resolve(process.env.HOME ?? "", ".codex");
  if (isDryRun) {
    recordBackground({ action: "ensure-dir", path: configDir, dryRun: true });
  } else {
    mkdirSync(configDir, { recursive: true });
  }

  const tomlPath = join(configDir, "config.toml");
  const tomlContent = buildConfigToml(envSnapshot);
  if (isDryRun) {
    console.log(`[setup] (dry-run) would write ${tomlPath}`);
  } else {
    writeFileSync(tomlPath, `${tomlContent}\n`, "utf8");
    console.log(`[setup] Configuration Codex Ã©crite dans ${tomlPath}`);
  }

  let summary = "";
  if (envSnapshot.startMcpBg) {
    const httpPidPath = join(projectRoot, ".mcp_http.pid");
    const fsPidPath = join(projectRoot, ".mcp_fsbridge.pid");
    killProcessIfPresent(httpPidPath, "http");
    killProcessIfPresent(fsPidPath, "fsbridge");

    let httpStatus = "STDIO fallback";
    if (envSnapshot.httpEnable) {
      const httpSpawn = spawnDetached("http", "start:http", ".mcp_http.out", ".mcp_http.pid");
      if (httpSpawn.ok) {
        httpStatus = "HTTP OK";
      } else {
        spawnDetached("stdio", "start:stdio", ".mcp_http.out", ".mcp_http.pid");
      }
    } else {
      spawnDetached("stdio", "start:stdio", ".mcp_http.out", ".mcp_http.pid");
    }

    ensureFsBridgeDirectories(envSnapshot.fsBridgeDir);
    spawnDetached("fsbridge", "start:fsbridge", ".mcp_fsbridge.out", ".mcp_fsbridge.pid");

    summary = `${httpStatus} + FS-Bridge actif`;
    console.log(`[setup] ${summary}`);
  }

  if (isDryRun) {
    globalThis.CODEX_SCRIPT_COMMANDS = recordedCommands;
    globalThis.CODEX_SCRIPT_ENV = envSnapshot;
    globalThis.CODEX_SCRIPT_CONFIG = tomlContent;
    globalThis.CODEX_SCRIPT_BACKGROUND = backgroundActions.slice();
    globalThis.CODEX_SCRIPT_SUMMARY = summary;
  }
}

if (!isTestEnvironment && invokedDirectly) {
  await main();
}

export { main as runSetupEnvironment };
