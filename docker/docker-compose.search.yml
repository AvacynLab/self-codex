version: "3.9"

# Docker Compose stack dedicated to the search subsystem. The file keeps the
# services isolated from the default development environment so contributors can
# opt-in only when working on the search pipeline. Resource limits and logging
# caps are applied so the stack remains CI friendly.
services:
  searxng:
    image: searxng/searxng:latest
    container_name: mcp-searxng
    restart: unless-stopped
    ports:
      - "127.0.0.1:8080:8080"
    volumes:
      - ./searxng/settings.yml:/etc/searxng/settings.yml:ro
    healthcheck:
      # HTTP based readiness probe so `depends_on` can rely on the
      # `service_healthy` condition. We target the landing page instead
      # of the `/search` endpoint so the check stays local to the
      # container and avoids contacting external engines during CI. The
      # probe uses the bundled Python runtime (always present in the
      # SearxNG image) to avoid depending on curl or wget binaries that
      # may be removed in future releases. Some SearxNG builds return
      # HTTP 4xx codes for the landing page when `public_instance: false`
      # (e.g. 403 Forbidden) even though the service is ready. We treat
      # every response below 500 as healthy to avoid flapping on those
      # configurations while still failing on server-side errors.
      test:
        - CMD
        - python3
        - -c
        - |
            import sys
            from urllib import request, error

            try:
                response = request.urlopen("http://127.0.0.1:8080/", timeout=10)
            except error.URLError:
                sys.exit(1)
            except Exception:
                sys.exit(1)
            else:
                status = getattr(response, "status", 500)
                sys.exit(0 if status < 500 else 1)
      interval: 15s
      timeout: 10s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: 1024M
    logging:
      driver: json-file
      options:
        max-size: 10m
        max-file: "3"
    networks:
      - search_net

  unstructured:
    image: quay.io/unstructured-io/unstructured-api:latest
    container_name: mcp-unstructured
    restart: unless-stopped
    ports:
      - "127.0.0.1:8000:8000"
    healthcheck:
      # The upstream image does not always ship convenient HTTP clients such as
      # curl, so we rely on the Python runtime that powers the API itself. Some
      # builds expose `python3` while others only ship `python`, so we detect
      # the first available interpreter and execute a shared probe script. The
      # heredoc keeps the Python code readable while avoiding any Compose
      # variable interpolation (thanks to the single-quoted terminator).
      test:
        - CMD-SHELL
        - |
            if command -v python3 >/dev/null 2>&1; then
              python3 - <<'PY'
            import sys
            from urllib import request, error

            STATUS_OK_MAX = 499
            URL = "http://127.0.0.1:8000/healthcheck"

            try:
                response = request.urlopen(URL, timeout=10)
            except error.HTTPError as http_error:
                sys.exit(0 if http_error.code <= STATUS_OK_MAX else 1)
            except error.URLError:
                sys.exit(1)
            except Exception:
                sys.exit(1)
            else:
                status = getattr(response, "status", 500)
                sys.exit(0 if status <= STATUS_OK_MAX else 1)
            PY
              exit $?;
            elif command -v python >/dev/null 2>&1; then
              python - <<'PY'
            import sys
            from urllib import request, error

            STATUS_OK_MAX = 499
            URL = "http://127.0.0.1:8000/healthcheck"

            try:
                response = request.urlopen(URL, timeout=10)
            except error.HTTPError as http_error:
                sys.exit(0 if http_error.code <= STATUS_OK_MAX else 1)
            except error.URLError:
                sys.exit(1)
            except Exception:
                sys.exit(1)
            else:
                status = getattr(response, "status", 500)
                sys.exit(0 if status <= STATUS_OK_MAX else 1)
            PY
              exit $?;
            else
              exit 1;
            fi
      interval: 15s
      timeout: 10s
      retries: 5
    deploy:
      resources:
        limits:
          cpus: "1"
          memory: 1536M
    logging:
      driver: json-file
      options:
        max-size: 10m
        max-file: "3"
    networks:
      - search_net

  server:
    container_name: mcp-search-server
    build:
      context: ..
      dockerfile: Dockerfile
    restart: unless-stopped
    depends_on:
      searxng:
        condition: service_healthy
      unstructured:
        condition: service_healthy
    environment:
      START_HTTP: "1"
      MCP_HTTP_HOST: 0.0.0.0
      MCP_HTTP_PORT: "8765"
      MCP_HTTP_PATH: /mcp
      MCP_HTTP_ALLOW_NOAUTH: "1"
      MCP_RUNS_ROOT: /app/validation_run
      MCP_LOG_FILE: /app/validation_run/logs/self-codex.log
      SEARCH_SEARX_BASE_URL: http://searxng:8080
      SEARCH_SEARX_API_PATH: /search
      SEARCH_SEARX_TIMEOUT_MS: "15000"
      SEARCH_SEARX_ENGINES: ddg,wikipedia,arxiv,github,mojeek
      SEARCH_SEARX_CATEGORIES: general,news,images,files
      SEARCH_FETCH_TIMEOUT_MS: "20000"
      SEARCH_FETCH_MAX_BYTES: "15000000"
      SEARCH_FETCH_UA: CodexSearchBot/1.0
      SEARCH_FETCH_RESPECT_ROBOTS: "1"
      SEARCH_PARALLEL_FETCH: "4"
      SEARCH_PARALLEL_EXTRACT: "2"
      SEARCH_MAX_RESULTS: "12"
      UNSTRUCTURED_BASE_URL: http://unstructured:8000
      UNSTRUCTURED_TIMEOUT_MS: "30000"
      UNSTRUCTURED_STRATEGY: hi_res
      SEARCH_INJECT_GRAPH: "1"
      SEARCH_INJECT_VECTOR: "1"
    ports:
      - "127.0.0.1:8765:8765"
    logging:
      driver: json-file
      options:
        max-size: 10m
        max-file: "3"
    networks:
      - search_net

networks:
  search_net:
    driver: bridge
