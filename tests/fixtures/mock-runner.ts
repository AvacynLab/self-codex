import readline from "node:readline";

/**
 * Message emitted by the mock runner. Only the `type` field is required so the
 * orchestrator can route structured events; other properties reflect the
 * various payloads used across the test suite (responses, heartbeats, errors,
 * etc.).
 */
export type RunnerMessage = {
  type: string;
  [key: string]: unknown;
};

/**
 * Envelope accepted by the runner. The union mirrors the prompts generated by
 * the child orchestration code paths. The handler purposefully keeps the
 * structure permissive because many tests inject ad-hoc properties when
 * exploring edge cases (timeouts, retries, metadata propagation).
 */
type RunnerCommand =
  | { type: "prompt"; content?: unknown }
  | { type: "ping" }
  | { type: string; [key: string]: unknown };

process.stdin.setEncoding("utf8");

const rl = readline.createInterface({
  input: process.stdin,
  crlfDelay: Infinity,
});

let counter = 0;

/**
 * Serialise a structured message on stdout so the orchestrator can interpret
 * the interaction. Keeping the implementation centralised ensures the emitted
 * payloads are always valid JSON strings with newline framing.
 */
function emit(payload: RunnerMessage): void {
  process.stdout.write(`${JSON.stringify(payload)}\n`);
}

emit({ type: "ready", pid: process.pid, argv: process.argv.slice(2) });

rl.on("line", (line: string) => {
  const trimmed = line.trim();
  if (!trimmed) {
    return;
  }

  let payload: RunnerCommand;
  try {
    payload = JSON.parse(trimmed) as RunnerCommand;
  } catch (error) {
    emit({
      type: "error",
      message: "invalid-json",
      raw: trimmed,
      detail: error instanceof Error ? error.message : String(error),
    });
    return;
  }

  counter += 1;

  if (payload.type === "prompt") {
    emit({ type: "response", id: counter, content: payload.content ?? null });
    return;
  }

  if (payload.type === "ping") {
    emit({ type: "pong", id: counter, ts: Date.now() });
    return;
  }

  emit({ type: "echo", id: counter, payload });
});

const graceful = (signal: NodeJS.Signals | string): void => {
  emit({ type: "shutdown", signal });
  rl.close();
  process.exit(0);
};

process.on("SIGINT", () => graceful("SIGINT"));
process.on("SIGTERM", () => graceful("SIGTERM"));

rl.on("close", () => {
  emit({ type: "closed" });
});

